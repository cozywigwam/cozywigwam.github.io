#+OPTIONS: toc:nil -:nil H:6 ^:nil
#+EXCLUDE_TAGS: noexport
#+BEGIN_EXAMPLE
---
title: "Programming"
layout: notation
description: "ðŸ’š"
path: "/programming/"
---
#+END_EXAMPLE

* Algorithms
** Big O

- O(n) - linear time, e.g. simple search
- O(log n) - log time, e.g. binary search
- O(n * log n) - fast sorting algorithm, e.g. quicksort
- O(n2
** Binary Search

Works for sorted arrays.

Split the results in half, and ask higher or lower?

#+BEGIN_SRC python
def binary_search(list, item):
  low = 0
  high = len(list)-1

  while low <= high:
    mid = (low + high) / 2
    guess = list[mid]
    if guess == item:
      return mid
    if guess > item:
      high = mid - 1
    else:
      low = mid + 1
  return None

my_list = [1, 3, 5, 7, 9]

print binary_search(my_list, 9)
#+END_SRC

** Breadth-first search

[[https://www.manning.com/books/grokking-algorithms][Grokking Algorithms by Aditya Y. Bhargava]]

#+BEGIN_SRC python
from collections import deque

def person_is_seller(name):
    return name[-1] == 'm'

graph = {}
graph["you"] = ["alice", "bob", "claire"]
graph["bob"] = ["anuj", "peggy"]
graph["alice"] = ["peggy"]
graph["claire"] = ["thom", "jonny"]
graph["anuj"] = []
graph["peggy"] = []
graph["thom"] = []
graph["jonny"] = []

def search(name):
    search_queue = deque()
    search_queue += graph[name]
    searched = []
    while search_queue:
        person = search_queue.popleft()
        if not person in searched:
            if person_is_seller(person):
                print person + ' found'
                return True
            else:
                search_queue += graph[person]
                searched.append(person)
    return False
#+END_SRC

#+BEGIN_SRC python
from collections import deque

graph = {}
graph["you"] = ["alice", "bob", "claire"]
graph["bob"] = ["anuj", "peggy"]
graph["alice"] = ["peggy"]
graph["claire"] = ["thom", "jonny"]
graph["anuj"] = []
graph["peggy"] = []
graph["thom"] = []
graph["jonny"] = []

def search(name, target):
    search_queue = deque()
    search_queue += graph[name]
    searched = []
    while search_queue:
        person = search_queue.popleft()
        if not person in searched:
            if person == target:
                print person + ' found'
                return True
            else:
                search_queue += graph[person]
                searched.append(person)
    return False
#+END_SRC

** Misc
** Quicksort
*** C

 Credit: [[http://knking.com/books/c2/index.html][K. N. King, C Programming: A Modern Approach, Second Edition]]

 #+BEGIN_SRC c
#include <stdio.h>

#define N 10

void quicksort(int a[], int low, int high);
int split(int a[], int low, int high);

int main(void)
{
  int a[N], i;

  printf("Enter %d numbers to be sorted: ", N);
  for (i = 0; i < N; i++)
    scanf("%d", &a[i]);

  quicksort(a, 0, N - 1);
  printf("In sorted order: ");
  for (i = 0; i < N; i++)
    printf("%d ", a[i]);
  printf("\n");

  return 0;
}

void quicksort(int a[], int low, int high)
{
  int middle;

  if (low >= high) return;
  middle = split(a, low, high);
  quicksort(a, low, middle - 1);
  quicksort(a, middle + 1, high);
}

int split(int a[], int low, int high)
{
  int part_element = a[low];

  for (;;) {
    while (low < high && part_element <= a[high])
      high--;
    if (low >= high) break;
    a[low++] = a[high];

    while (low < high && a[low] <= part_element)
      low++;
    if (low >= high) break;
    a[high--] = a[low];
  }

  a[high] = part_element;
  return high;
}
 #+END_SRC

*** java

 http://gauss.ececs.uc.edu/Courses/C321/html/quicksort.java.html

 University of Cincinatti

 #+BEGIN_SRC java
import java.io.*;
import java.util.*;

public class QuickSort
{
  public static void swap (int A[], int x, int y)
  {
    int temp = A[x];
    A[x] = A[y];
    A[y] = temp;
  }

  // Reorganizes the given list so all elements less than the first are
  // before it and all greater elements are after it.
  public static int partition(int A[], int f, int l)
  {
    int pivot = A[f];
    while (f < l)
      {
        if (A[f] == pivot || A[l] == pivot)
          {
            System.out.println("Only distinct integers allowed - C321");
            System.out.println("students should ignore this if statement");
            System.out.exit(0);
          }
        while (A[f] < pivot) f++;
        while (A[l] > pivot) l--;
        swap (A, f, l);
      }
    return f;
  }

  public static void Quicksort(int A[], int f, int l)
  {
    if (f >= l) return;
    int pivot_index = partition(A, f, l);
    Quicksort(A, f, pivot_index);
    Quicksort(A, pivot_index+1, l);
  }

  // Usage: java QuickSort [integer] ...
  // All integers must be distinct
  public static void main(String argv[])
  {
    int A[] = new int[argv.length];
    for (int i=0 ; i < argv.length ; i++)
      A[i] = Integer.parseInt(argv[i]);

    Quicksort(A, 0, argv.length-1);

    for (int i=0 ; i < argv.length ; i++) System.out.print(A[i] + " ");
    System.out.println();
  }
}
 #+END_SRC

*** javascript

 #+BEGIN_SRC js
const qs3 = arr => {
  if (!arr.length) return [];
  const [head, ...tail] = arr,
    lt = tail.filter(x => x < head),
    gt = tail.filter(x => x >= head);
  return qs3(lt).concat(head, qs3(gt));
};
 #+END_SRC

*** python

 #+BEGIN_SRC python
def quicksort(array):
  if len(array) < 2:
    return array
  else:
    pivot = array[0]
    less = [i for i in array[1:] if i <= pivot]
    greater = [i for i in array[1:] if i > pivot]

    return quicksort(less) + [pivot] + quicksort(greater)

  print quicksort([10, 5, 2, 3])
 #+END_SRC

*** ruby

 Common-Sense Guide to Data Structures and Algorithms, by Jay Wengrow

 #+BEGIN_SRC ruby
class SortableArray
  attr_reader :array
  def initialize(array)
    @array = array
  end
  def partition!(left_pointer, right_pointer)
    # right-most as pivot
    pivot_position = right_pointer
    pivot = @array[pivot_position]
    # start right pointer immediately to left of pivot
    right_pointer -= 1
    while true do
      whilte @array[left_pointer] < pivot do
        left_pointer += 1
      end
      while @array[right_pointer] > pivot do
        right_pointer -= 1
      end
      if left_pointer >= right_pointer
        break
      else
        swap(left_pointer, right_pointer)
      end
    end

    # swap left pointer with pivot
    swap(left_pointer, pivot_position)
    return left_pointer
  end

  def swap(pointer_1, pointer_2)
    temp_value = @array[pointer_1]
    @array[pointer_1] = @array[pointer_2]
    @array[pointer_2] = temp_value
  end
end

def quicksort!(left_index, right_index)
  # base case: subarray has 0 or 1
  if right_index - left_index <= 0
    return
  end
  # partition array and grab position of pivot
  pivot_position = partition!(left_index, right_index)
  quicksort!(left_index, pivot_position - 1)
  quicksort!(pivot_position + 1, right_index)
end

array = [0, 5, 2, 1, 6, 3]
sortable_array = SortableArray.new(array)
sortable_array.quicksort!(0, array.length - 1)
p sortable_array.array
 #+END_SRC

** Selection Sort

 Run through the whole list to select the highest/lowest, and repeat /n/ times.

 Define a mutable ~sorted~ array. Loop through the array, each time popping one "sorted" element (e.g. smallest), and appending it to ~sorted~. The sorting function returns the index indicating the smallest element.

*** python

 #+BEGIN_SRC python
def findSmallest(arr):
  smallest = arr[0]
  smallest_index = 0
  for i in range(1, len(arr)):
    if arr[i] < smallest:
      smallest = arr[i]
      smallest_index = i
  return smallest_index

def selectionSort(arr):
  newArr = []
  for i in range(len(arr)):
    smallest = findSmallest(arr)
    newArr.append(arr.pop(smallest))
  return newArr
 #+END_SRC

*** javascript

 #+BEGIN_SRC js
  // array to sort
  var array = [9, 2, 5, 6, 4, 3, 7, 10, 1, 8];

  // swap function helper
  function swap(array, i, j) {
    var temp = array[i];
    array[i] = array[j];
    array[j] = temp;
  }

  function selectionSort(array) {
    for(var i = 0; i < array.length; i++) {
      var min = i;
      for(var j = i + 1; j < array.length; j++) {
        if(array[j] < array[min]) {
          min = j;
        }
      }
      if(i !== min) {
        swap(array, i, min);
      }
    }
    return array;
  }

  console.log(selectionSort(array));
 #+END_SRC

 #+RESULTS:
 : [1 (\, 2) (\, 3) (\, 4) (\, 5) (\, 6) (\, 7) (\, 8) (\, 9) (\, 10)]

* Code
** Add numbers recursively

#+BEGIN_SRC python
def sum(arr):
  total = 0
  for x in arr:
    total += x
  return total

def rAdd(arr):
  if (arr.length > 1):
    rAdd(arr.pop + arr)
  return arr
#+END_SRC

** Expression Problem

coined by Philip Wadler in an email, Bell Labs, 1998 ([[https://www.ibm.com/developerworks/java/library/j-clojure-protocols/?ca=drs-#expression][ref]])

http://www.daimi.au.dk/~madst/ecoop04/main.pdf

#+BEGIN_QUOTE
The expression problem (aka the extensibility problem)  refers to a fundamental dilemma of programming: To which degree can your application be structured in such a way that both the data model and the set of virtual operations over it can be extended without the need to modify existing code, without the need for code repetition and without runtime type errors.
#+END_QUOTE

[[https://www.ibm.com/developerworks/java/library/j-clojure-protocols/?ca=drs][Solving the Expression Problem with Clojure 1.2]]-, by Stuart Sierra

** Factorial
*** clojure

#+BEGIN_SRC clojure
(def factorial
  (fn [n]
    (loop [cnt n acc 1]
      (if (zero? cnt)
        acc
        (recur (dec cnt) (* acc cnt))))))
#+END_SRC

*** common lisp

#+BEGIN_SRC lisp
(defun fact (n)
  (if (zerop n) 1
      (* n (fact (1- n)))))
#+END_SRC
*** emacs lisp

#+BEGIN_SRC emacs-lisp
(defun fact (n)
  (if (zerop n) 1
    (* n (fact2 (1- n)))))
#+END_SRC

*** js

#+BEGIN_SRC js
function fac(n) {
  if (n === 0 || n === 1) {
    return n
  } else {
    return n * fac(n - 1)
  }
)
#+END_SRC

*** Pascal

rom Data Structures and Algorithms, Aho, Hopcroft, Ullman (1987).

#+BEGIN_SRC pascal
function fact (n: integer) : integer;
  Begin
    If N <= 1 Then
      return(1)
    Else
      return(n * fact(n - 1))
  End; { fact }
#+END_SRC

*** python

#+BEGIN_SRC python
def fac(n):
  if (n == 0):
    return 1
  else:
    return n * fac(n - 1)
#+END_SRC

*** scheme

#+BEGIN_SRC scheme
(define (fac n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (* n (fac (- n 1))))))
#+END_SRC

#+BEGIN_SRC scheme
(define (fac2 n)
  (define (fac-iter count acc)
    (if (= count 0)
        acc
        (fac-iter (- count 1) (* acc count))))
  (fac-iter n 1))
#+END_SRC

*** sml

#+BEGIN_SRC sml
fun factiter(count : int, acc : int) =
    if count=0
    then acc
    else factiter(count-1, acc * count);

fun fact2(x : int) =
    factiter(x, 1);

fun fact(x : int) =
    if x=0
    then 1
    else x * fact(x - 1);
#+END_SRC

** Fahrenheit to Celsius

#+BEGIN_SRC c
int main(void)
{
  float fahrenheit, celsius;

  printf("Enter Fahrenheit: ");
  scanf("%f", &fahrenheit);

  celsius = (fahrenheit - FREEZING_PT) * SCALE_FACTOR;

  printf("Calesius equivalent: %.1f\n", celsius);

  return 0;
}

#+END_SRC
** Fibonacci
*** clojure

#+BEGIN_SRC clojure
defn fib
 [n]
 (loop [a 0 b 1 i n]
   (if (zero? i)
     a
     (recur b (+ a b) (dec i)))))
#+END_SRC

#+BEGIN_SRC clojure
;; lazy infinite sequence
(def fibs (cons 0 (cons 1 (lazy-seq (map +' fibs (rest fibs))))))

;; list of first 10 Fibonacci numbers taken from infinite sequence
(take 10 fibs)
#+END_SRC

*** js

#+BEGIN_SRC js
function fib(n) {
  if (n === 0 || n === 1) {
    return n
  } else {
    return fib(n - 1) + fib(n - 2)
  }
#+END_SRC

#+BEGIN_SRC js
const fibIter = (a, b, n) => {
  if (n === 0) {
    return b
  } else {
    return fibIter(a + b, a, n - 1)
  }

function fib2(n) {
  return fibIter(1, 1, n)
#+END_SRC

*** python

#+BEGIN_SRC python
def fib(n, first = 0, second = 1):
  for _ in range(n):
    first, second = second, first + second
  return second
#+END_SRC

#+BEGIN_SRC python
def fib2(n):
  def fibi(a, b, n):
    if n == 0:
      return b
    else:
      return fibi(a + b, a, n - 1)
  return fibi(1, 1, n)
#+END_SRC

*** scheme

#+BEGIN_SRC scheme
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
#+END_SRC

#+BEGIN_SRC scheme
(define (fib n)
  (define (fib-iter a b count)
    (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1))))
  (fib-iter 1 1 n))
#+END_SRC

** Prime numbers

find primes ([[https://www.sitepoint.com/functional-reactive-programming-rxjs/][ref]])

#+BEGIN_SRC js
function (start, end) {
  var n = start - 1;

  while (n++ < end) {
    var k = Math.sqrt(n);
    var found = false;

    for (var i = 2; !found && i <= k; ++i) {
      found = n % i === 0;
    }

    if (!found) {
      return n;
    }
  }
}
#+END_SRC

** Recursion

[[https://sarabander.github.io/sicp/html/1_002e2.xhtml#g_t1_002e2_002e1][SICP]]

#+BEGIN_QUOTE
linear recursive process - ...the length of the chain of deferred multiplications, and hence the amount of information needed to keep track of it, grows linearly with ~n~.
#+END_QUOTE

#+BEGIN_QUOTE
linear iterative process - In computing ~n!~, the number of steps required grows linearly with ~n~.

The contrast between the two processes can be seen in another way. In the iterative case, the program variables provide a complete description of the state of the process at any point.
#+END_QUOTE

Iterative processes execute in constant space.

*** Exercise 1.9                                                 :no_export:

Each of the following two procedures defines a method for adding two positive integers in terms of the procedures inc, which increments its argument by 1, and dec, which decrements its argument by 1.

#+BEGIN_SRC scheme
(define (+ a b)
  (if (= a 0)
      b
      (inc (+ (dec a) b))))

(define (+ a b)
  (if (= a 0)
      b
      (+ (dec a) (inc b))))
#+END_SRC

Using the substitution model, illustrate the process generated by each procedure in evaluating (+ 4 5). Are these processes iterative or recursive?

** Square Root

* Data
** books

*** [[https://dataintensive.net/][Designing Data-Intensive Applications]], by [[https://martin.kleppmann.com/][Martin Kleppmann]]

 #+BEGIN_QUOTE
 In an ideal world, the running time of a batch job is the size of the dataset divided by the throughput. testz  In practice, the running time is often longer, due to skew (data not being spread evenly across worker processes) and needing to wait for the slowest task to compete.
 #+END_QUOTE

 Impedance mismatch (borrowed from electronics) - ...an awkward translation layer is required between the objects in the application code and the database model of tables, rows, and columns.

 #+BEGIN_QUOTE
 As a rule of thumb, if you're duplicating values that could be stored in just one place, the schema is not normalized.
 #+END_QUOTE

 #+BEGIN_QUOTE
 Even CODASYL committee members admitted that this was like navigating around an [n]-dimensional data space.

 cited Charles W. Bachman: "the Programmer as Navigator," Communications of the ACM, volume 16, number 11, pages 653-658, November 1973
 #+END_QUOTE
** databases
*** couch

 http://couchdb.apache.org/

 [[http://docs.couchdb.org/en/2.1.1/intro/tour.html][Getting started docs]]

 Web access: http://127.0.0.1:5984/_utils/

 #+BEGIN_SRC sh
# running?
curl http://127.0.0.1:5984/

# list dbs
curl -X GET http://127.0.0.1:5984/_all_dbs

# create db
curl -X PUT http://127.0.0.1:5984/baseball
 #+END_SRC

** graphQL

reference

Example GraphQL SDL syntax data model:

#+BEGIN_SRC sh
type User {
  id: ID! @unique
  email: String @unique
  name: String!
  posts: [Post!]!
}

type Post {
  id: ID! @unique
  title: String!
  published: Boolean! @default(value: "false")
  author: User
}
#+END_SRC

*** Apollo

[[https://codesandbox.io/s/r5qp83z0yq][demo app]]

[[https://www.apollographql.com/docs/react/essentials/queries.html][queries]]

*** reference

[[https://graphql.github.io/learn/queries/][Queries and Mutations]]

#+BEGIN_SRC  gql
{
  human(id: "1000") {
    name
    height(unit: FOOT)
  }
}
#+END_SRC

aliases:

#+BEGIN_SRC gql
{
  empireHero: hero(episode: EMPIRE) {
    name
  }
  jediHero: hero(episode: JEDI) {
    name
  }
}
#+END_SRC

fragments:

#+BEGIN_SRC gql

#+END_SRC

** misc
*** SDL - Schema Definition Language

 A "schema definition" specifies a schema. The definitions are sometimes referred to as IDL or SDL. [ref](https://www.graph.cool/docs/faq/graphql-idl-schema-definition-language-kr84dktnp0/)

 SDL - Schema Definition Language

 IDL ([[https://en.wikipedia.org/wiki/Interface_description_language][interface description language)]] - API spec

** Structures
*** Graphs

- adjacency list
- adjacency matrix
- incidence matrix

*** Lists
**** Data Structures and Algorithms, Aho, Hopcroft, Ullman.

 Operations:

 - ~INSERT(x, p, L)~
 - ~LOCATE(x, L)~
 - ~RETRIEVE(p, L)~
 - ~DELETE(p, L)~
 - ~NEXT(p, L)~
 - ~MAKENULL(L)~
 - ~FIRST(L)~
 - ~PRINTLIST(L)~

 Example program, independent of list representation:

 > p will be the "current" position in L, and q will move ahead to find equal elements

 #+BEGIN_SRC pascal
procedure PURGE ( var L: LIST );
  { PURGE removes duplicate elements from list L }
  var
     p, q: position;
  begin
     p := FIRST(L);
     while p <> END(L) do begin
        q := NEXT(p, L);
        while q <> END(L) do
          if same(RETRIEVE(p, L), RETRIEVE(q, L))
             then DELETE(q, L)
          else
             q := NEXT(q, L);
        p := NEXT(p, L)
      end
end; { PURGE }
 #+END_SRC

***** Array implementation

 > Define the type ~LIST~ to be a record having two fields. The first field is an array of elements whose length is sufficient to hold the maximum size list that will be encountered. The second field is an integer ~last~ indicating the position of the last list element in the array.

 #+BEGIN_SRC pascal
const maxlength = 100; { some suitable constant }
type
   LIST = record
             elements : array[1...maxlength] of elementtype;
             last     : integer
          end;
          position =  integer;
function END ( var L: LIST ): position;
begin
   return (L.last + 1)
end; { END }
 #+END_SRC

 > INSERT moves the elements at location ~p~, ~p+1~, â€¦, ~last~ into locations ~p+1~, ~p+2~, â€¦, ~last+1~ and then inserts the new element at location ~p~.

 #+BEGIN_SRC pascal
procedure INSERT ( x: elementtype; p: position; var L: LIST);
{ INSERT places x at position p in list L }
var
   q :  position;
   begin
      if L.last >= maxlength thne
         error('listi s full')
      else if (p > L.last + 1) or (p < 1) then
         error('position does not exist')
         else begin
            for q := L.las downto p do
               {shift elements at p, p+1, ... down one position }
               L.elements[q + 1] := L.elements[q];
            L.last := L.loast + 1;
            L.elements[p] := x
            end
   end; { INSERT }
 #+END_SRC

 > DELETE removes the element at position ~p~ by moving the elements at positions ~p+1~, ~p+2~, â€¦, ~last~ into position ~p~, ~p+1~, â€¦, ~last-1~.

 #+BEGIN_SRC pascal
procedure DELEETE ( p: position; var L: LIST) ;
{ DELETE removes the element at position p of list L }
var
   q :  position;
begin
    if (p > L.last) or (p < l) then
      error('position does not exist')
    else begin
         L.last := L.last - 1;
         for q := p to L.last do
            { shift elements at p+1, p+2, . . . up on poistion }
            L.elements[q] := L.elements[q+1]
    end
end; { DELETE }
 #+END_SRC

 > LOCATE sequentially scans the array to look for a given element. If the element is not found, LOCATE returns ~last+1~.

 #+BEGIN_SRC pascal
function LOCATE ( x: elemenettype; L: LIST ): position;
{ LOCATE returns the position of x on list L }
  var
      q :  position;
  begin
      for q := 1 to L.last do
          if L.elements[q] = x then
            return(q);
      return (L.last + 1) { if not found }
  end; { LOCATE }
 #+END_SRC

***** Pointer
***** Cursor
*** Trees
**** Red Black Trees

 http://www.eternallyconfuzzled.com/tuts/datastructures/jsw_tut_rbtree.aspx, Julienne Walker
* Functional Programming
** Misc
*** Why Functional Programming Matters

[[http://www.cse.chalmers.se/%257Erjmh/Papers/whyfp.pdf][Why Functional Programming Matters (PDF) by John Hughes]]

[[https://github.com/epsil/whyfp/blob/master/whyfp.hs][Haskell translation]] by Vegard Ã˜ye:

#+BEGIN_SRC haskell
-- Exclude Haskell primitives defined in the article

import Prelude hiding (foldr, sum, product, length, (.), map, iterate,
                       sqrt, zipWith, maximum, minimum, take)
import Data.List (intersperse)
import qualified Data.List as D (sort, sortBy)
import qualified Prelude as P (map, foldr, sum, length, maximum,
                               minimum, take)

-- Gluing Functions Together

data List a = Cons a (List a) | Nil deriving Show

sum = foldr (+) 0

foldr f x Nil = x
foldr f x (Cons a l) = f a (foldr f x l)

product = foldr (*) 1

or = foldr (||) False

and = foldr (&&) True

append a b = foldr Cons b a

length = foldr count 0
count a n = n + 1

double n = 2 * n

(f . g) h = f (g h)

doubleAll = map double
map f = foldr (Cons . f) Nil

sumMatrix = sum . map sum

data Tree a = Node a (List (Tree a)) deriving Show

foldTree f g a (Node label subtrees) =
    f label (foldr (g . foldTree f g a) a subtrees)

sumTree = foldTree (+) (+) 0

labels = foldTree Cons append Nil

mapTree f = foldTree (Node . f) Cons Nil

-- Gluing Programs Together

--- Newton-Raphson Square Roots

next n x = (x + n / x) / 2

iterate f a = Cons a (iterate f (f a))

within eps (Cons a (Cons b rest))
    | abs (a - b) <= eps = b
    | otherwise          = within eps (Cons b rest)

sqrt a0 eps n = within eps (iterate (next n) a0)

relative eps (Cons a (Cons b rest))
    | abs (a / b - 1) <= eps = b
    | otherwise              = relative eps (Cons b rest)

relativeSqrt a0 eps n = relative eps (iterate (next n) a0)

--- Numerical Differentiation

easyDiff f x h = (f (x + h) - f x) / h

differentiate h0 f x = map (easyDiff f x) (iterate halve h0)
halve x = x / 2

elimError n (Cons a (Cons b rest)) =
    Cons ((b * (2 ** n) - a) / (2 ** n - 1))
         (elimError n (Cons b rest))

order (Cons a (Cons b (Cons c rest))) =
    fromIntegral (round (logBase 2 ((a - c) / (b - c) - 1)))

improve s = elimError (order s) s

super s = map second (iterate improve s)
second (Cons a (Cons b rest)) = b

--- Numerical Integration

easyIntegrate f a b = (f a + f b) * (b - a) / 2

zipWith f (Cons a s) (Cons b t) = Cons (f a b) (zipWith f s t)

integrate f a b = integ f a b (f a) (f b)
integ f a b fa fb =
    Cons ((fa + fb) * (b - a) / 2)
         (zipWith (+) (integ f a m fa fm)
                      (integ f m b fm fb))
    where m  = (a + b) / 2
          fm = f m

-- An Example from Artificial Intelligence

repTree f a = Node a (map (repTree f) (f a))

gameTree p = repTree moves p

maximize (Node n Nil)  =  Cons n Nil
maximize (Node n l)    =  mapMin (map minimize l)

minimize (Node n Nil)  =  Cons n Nil
minimize (Node n l)    =  mapMax (map maximize l)

mapMin  (Cons nums rest) =
        Cons (minimum nums) (omit (minimum nums) rest)

mapMax  (Cons nums rest) =
        Cons (maximum nums) (omit (maximum nums) rest)

omit pot Nil = Nil
omit pot (Cons nums rest)
    | minLeq nums pot  =  omit pot rest
    | otherwise        =  Cons  (minimum nums)
                                (omit (minimum nums) rest)
minLeq Nil pot = False
minLeq (Cons n rest) pot
    | n <= pot   =  True
    | otherwise  =  minLeq rest pot

highFirst (Node n sub) = Node n (sortBy higher (map lowFirst sub))
lowFirst (Node n sub) = Node n (sortBy (flip higher) (map highFirst sub))
higher (Node n1 sub1) (Node n2 sub2) = compare n2 n1

evaluate =
    maximum . maximize . highFirst . mapTree static . prune 8 . gameTree

takeTree n = foldTree (nodett n) Cons Nil
nodett n label sub = Node label (take n sub)

prune 0 (Node pos sub)
    | dynamic pos  =  Node pos (map (prune 0) sub)
    | otherwise    =  Node pos Nil
prune n (Node a x)  =  Node a (map (prune (n - 1)) x)

data Square = Empty | Nought | Cross
    deriving Eq

instance Show Square where
  show Empty  = " "
  show Nought = "O"
  show Cross  = "X"

data Board = Board [[Square]]
  deriving Eq

instance Show Board where
  show (Board rows) =
    "\n" ++ concat (intersperse "-+-+-\n" $ map' showRow rows) ++ "\n"
    where showRow cols = concat (intersperse "|" $ map' show cols) ++ "\n"

type Position = Board

emptyBoard = Board [[Empty,Empty,Empty],
                    [Empty,Empty,Empty],
                    [Empty,Empty,Empty]]

update i x [] = []
update i x (y:ys)
  | i == 0 = x : ys
  | otherwise = y : update (i - 1) x ys

move :: Int -> Int -> Square -> Board -> Board
move x y p (Board b) = Board (update y (update x p (b !! y)) b)

getSquare :: Int -> Int -> Board -> Square
getSquare x y (Board b) = (b !! y) !! x

moves :: Board -> List Board
moves b = toList [move x y p b | y <- [0..2],
                                 x <- [0..2],
                                 getSquare x y b == Empty]
          where p = if countPlayer Cross b <= countPlayer Nought b
                    then Cross
                    else Nought
                countPlayer p (Board b) =
                    sum' $ map' (length' . filter (==p)) b

static = static' Cross

static' :: Square -> Board -> Integer
static' user (Board b) =
      case b of
           [[a, _, _],
            [_, b, _],
            [_, _, c]] | eq a b c -> win a user

           [[_, _, a],
            [_, b, _],
            [c, _, _]] | eq a b c -> win a user

           [[a, b, c],
            [_, _, _],
            [_, _, _]] | eq a b c -> win a user

           [[_, _, _],
            [a, b, c],
            [_, _, _]] | eq a b c -> win a user

           [[_, _, _],
            [_, _, _],
            [a, b, c]] | eq a b c -> win a user

           [[a, _, _],
            [b, _, _],
            [c, _, _]] | eq a b c -> win a user

           [[_, a, _],
            [_, b, _],
            [_, c, _]] | eq a b c -> win a user

           [[_, _, a],
            [_, _, b],
            [_, _, c]] | eq a b c -> win a user

           _ -> 0
    where
        eq a b c = a == b && b == c && a /= Empty
        win a user = if a == user then 1 else -1

dynamic p = False

sort' :: (Ord a) => [a] -> [a]
sort' = D.sort

sortBy' = D.sortBy

sort :: Ord a => List a -> List a
sort = toList . sort' . fromList

sortBy :: (a -> a -> Ordering) -> List a -> List a
sortBy compare = toList . sortBy' compare . fromList

take' :: Int -> [a] -> [a]
take' = P.take

take :: Int -> List a -> List a
take n = toList . take' n . fromList

map' = P.map
foldr' = P.map
sum' = P.sum
length' = P.length

maximum' :: (Ord a) => [a] -> a
maximum' = P.maximum
minimum' :: (Ord a) => [a] -> a
minimum' = P.minimum

maximum :: (Ord a) => List a -> a
maximum l = maximum' (fromList l)

minimum :: (Ord a) => List a -> a
minimum l = minimum' (fromList l)

toList :: [a] -> List a
toList [] = Nil
toList (x:xs) = Cons x (toList xs)

fromList :: List a -> [a]
fromList Nil = []
fromList (Cons x xs) = x : fromList xs
#+END_SRC
** Lambda Calculus
*** reference

[[https://github.com/tadeuzagallo/lc-js][lc-js: A Î»-calculus interpreter written in JavaScript]]

[[https://tadeuzagallo.com/blog/writing-a-lambda-calculus-interpreter-in-javascript/][A Î»-calculus interpreter]]

* Reactive/dataflow :noexport:

Suffixing observable names with `$` comes from cycle.js: https://cycle.js.org/basic-examples.html#basic-examples-increment-a-counter-what-is-the-convention
