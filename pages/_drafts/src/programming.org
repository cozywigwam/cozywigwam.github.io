#+EXCLUDE_TAGS: noexport
#+OPTIONS: toc:nil -:nil H:6 ^:nil
#+STARTUP: overview
#+BEGIN_EXAMPLE
---
title: "Programming"
layout: notation
description: "💚"
path: "/programming/"
---
#+END_EXAMPLE

* Algorithms
** Big O

- O(n) - linear time, e.g. simple search
- O(log n) - log time, e.g. binary search
- O(n * log n) - fast sorting algorithm, e.g. quicksort
- O(n2
** Binary Search

Works for sorted arrays.

Split the results in half, and ask higher or lower?

#+BEGIN_SRC python
def binary_search(list, item):
  low = 0
  high = len(list)-1

  while low <= high:
    mid = (low + high) / 2
    guess = list[mid]
    if guess == item:
      return mid
    if guess > item:
      high = mid - 1
    else:
      low = mid + 1
  return None

my_list = [1, 3, 5, 7, 9]

print binary_search(my_list, 9)
#+END_SRC

** books
*** A Common-Sense Guide to Data Structures and Algorithms :noexport:

by Jay Wengrow

**** chapter 2 - binary search vs. linear search in ordered arrays

#+BEGIN_SRC ruby
def binary_search(array, value)
  lower_bound = 0
  upper_bound = array.length - 1

  while lower_bound <= upper_bound do
    midpoint = (upper_bound + lower_bound) / 2

    value_at_midpoint = array[midpoint]

    if value < value_at_midpoint
      upper_bound = midpoint - 1
    elsif value > value_at_midpoint
      lower_bound = midpoint + 1
    elsif value == value_at_midpoint
      return midpoint
    end
  end

  return nil
end
#+END_SRC

#+BEGIN_SRC clojure
(defn rand-ints [n]
  (map (fn [x] (rand-int 10)) (repeat n 0)))

(defn linear-search [coll value]
  (cond (empty? coll) nil
        (= (first coll) value) value
        :else (linear-search (rest coll) value)))

(defn binary-search
  ([coll value] (binary-search coll value 0 (dec (count coll))))
  ([coll value lower upper]
   (let [midpoint (quot (+ lower upper) 2)
         midpoint-value (get coll midpoint)]
     (cond (> lower upper) nil
           (= midpoint-value value) value
           (> midpoint-value value) (binary-search coll value lower (dec midpoint))
           (< midpoint-value value) (binary-search coll value (inc midpoint) upper)))))

(linear-search (sort (rand-ints 10)) 4)
(binary-search (vec (sort (rand-ints 4))) 8)
#+END_SRC

with step counting:

#+BEGIN_SRC clojure
(defn rand-ints [n]
  (map (fn [x] (rand-int n)) (repeat n 0)))

(defn linear-search
  ([coll value] (linear-search coll value 0))
  ([coll value count]
   (cond (empty? coll) (hash-map :value nil :count count)
         (= (first coll) value) (hash-map :value value :count count)
         :else (linear-search (rest coll) value (inc count)))))

(defn binary-search
  ([coll value] (binary-search coll value 0 (dec (count coll)) 0))
  ([coll value lower upper count]
   (let [midpoint (quot (+ lower upper) 2)
         midpoint-value (get coll midpoint)]
     (cond (> lower upper) (hash-map :value nil :count count)
           (= midpoint-value value) (hash-map :value value :count count)
           (> midpoint-value value) (binary-search coll value lower (dec midpoint) (inc count))
           (< midpoint-value value) (binary-search coll value (inc midpoint) upper (inc count))))))

(linear-search (sort (rand-ints 100)) (rand-int 100))
(binary-search (vec (sort (rand-ints 100))) (rand-int 100))
#+END_SRC

** Breadth-first search

[[https://www.manning.com/books/grokking-algorithms][Grokking Algorithms by Aditya Y. Bhargava]]

#+BEGIN_SRC python
from collections import deque

def person_is_seller(name):
    return name[-1] == 'm'

graph = {}
graph["you"] = ["alice", "bob", "claire"]
graph["bob"] = ["anuj", "peggy"]
graph["alice"] = ["peggy"]
graph["claire"] = ["thom", "jonny"]
graph["anuj"] = []
graph["peggy"] = []
graph["thom"] = []
graph["jonny"] = []

def search(name):
    search_queue = deque()
    search_queue += graph[name]
    searched = []
    while search_queue:
        person = search_queue.popleft()
        if not person in searched:
            if person_is_seller(person):
                print person + ' found'
                return True
            else:
                search_queue += graph[person]
                searched.append(person)
    return False
#+END_SRC

#+BEGIN_SRC python
from collections import deque

graph = {}
graph["you"] = ["alice", "bob", "claire"]
graph["bob"] = ["anuj", "peggy"]
graph["alice"] = ["peggy"]
graph["claire"] = ["thom", "jonny"]
graph["anuj"] = []
graph["peggy"] = []
graph["thom"] = []
graph["jonny"] = []

def search(name, target):
    search_queue = deque()
    search_queue += graph[name]
    searched = []
    while search_queue:
        person = search_queue.popleft()
        if not person in searched:
            if person == target:
                print person + ' found'
                return True
            else:
                search_queue += graph[person]
                searched.append(person)
    return False
#+END_SRC

** Misc
*** Man or Boy Test

[[https://en.wikipedia.org/wiki/Man_or_boy_test][Wikipedia - Man or Boy Test]]

** Quicksort
*** C

 Credit: [[http://knking.com/books/c2/index.html][K. N. King, C Programming: A Modern Approach, Second Edition]]

 #+BEGIN_SRC c
#include <stdio.h>

#define N 10

void quicksort(int a[], int low, int high);
int split(int a[], int low, int high);

int main(void)
{
  int a[N], i;

  printf("Enter %d numbers to be sorted: ", N);
  for (i = 0; i < N; i++)
    scanf("%d", &a[i]);

  quicksort(a, 0, N - 1);
  printf("In sorted order: ");
  for (i = 0; i < N; i++)
    printf("%d ", a[i]);
  printf("\n");

  return 0;
}

void quicksort(int a[], int low, int high)
{
  int middle;

  if (low >= high) return;
  middle = split(a, low, high);
  quicksort(a, low, middle - 1);
  quicksort(a, middle + 1, high);
}

int split(int a[], int low, int high)
{
  int part_element = a[low];

  for (;;) {
    while (low < high && part_element <= a[high])
      high--;
    if (low >= high) break;
    a[low++] = a[high];

    while (low < high && a[low] <= part_element)
      low++;
    if (low >= high) break;
    a[high--] = a[low];
  }

  a[high] = part_element;
  return high;
}
 #+END_SRC

*** java

 http://gauss.ececs.uc.edu/Courses/C321/html/quicksort.java.html

 University of Cincinatti

 #+BEGIN_SRC java
import java.io.*;
import java.util.*;

public class QuickSort
{
  public static void swap (int A[], int x, int y)
  {
    int temp = A[x];
    A[x] = A[y];
    A[y] = temp;
  }

  // Reorganizes the given list so all elements less than the first are
  // before it and all greater elements are after it.
  public static int partition(int A[], int f, int l)
  {
    int pivot = A[f];
    while (f < l)
      {
        if (A[f] == pivot || A[l] == pivot)
          {
            System.out.println("Only distinct integers allowed - C321");
            System.out.println("students should ignore this if statement");
            System.out.exit(0);
          }
        while (A[f] < pivot) f++;
        while (A[l] > pivot) l--;
        swap (A, f, l);
      }
    return f;
  }

  public static void Quicksort(int A[], int f, int l)
  {
    if (f >= l) return;
    int pivot_index = partition(A, f, l);
    Quicksort(A, f, pivot_index);
    Quicksort(A, pivot_index+1, l);
  }

  // Usage: java QuickSort [integer] ...
  // All integers must be distinct
  public static void main(String argv[])
  {
    int A[] = new int[argv.length];
    for (int i=0 ; i < argv.length ; i++)
      A[i] = Integer.parseInt(argv[i]);

    Quicksort(A, 0, argv.length-1);

    for (int i=0 ; i < argv.length ; i++) System.out.print(A[i] + " ");
    System.out.println();
  }
}
 #+END_SRC

*** javascript

 #+BEGIN_SRC js
const qs3 = arr => {
  if (!arr.length) return [];
  const [head, ...tail] = arr,
    lt = tail.filter(x => x < head),
    gt = tail.filter(x => x >= head);
  return qs3(lt).concat(head, qs3(gt));
};
 #+END_SRC

*** python

 #+BEGIN_SRC python
def quicksort(array):
  if len(array) < 2:
    return array
  else:
    pivot = array[0]
    less = [i for i in array[1:] if i <= pivot]
    greater = [i for i in array[1:] if i > pivot]

    return quicksort(less) + [pivot] + quicksort(greater)

  print quicksort([10, 5, 2, 3])
 #+END_SRC

*** ruby

 Common-Sense Guide to Data Structures and Algorithms, by Jay Wengrow

 #+BEGIN_SRC ruby
class SortableArray
  attr_reader :array
  def initialize(array)
    @array = array
  end
  def partition!(left_pointer, right_pointer)
    # right-most as pivot
    pivot_position = right_pointer
    pivot = @array[pivot_position]
    # start right pointer immediately to left of pivot
    right_pointer -= 1
    while true do
      whilte @array[left_pointer] < pivot do
        left_pointer += 1
      end
      while @array[right_pointer] > pivot do
        right_pointer -= 1
      end
      if left_pointer >= right_pointer
        break
      else
        swap(left_pointer, right_pointer)
      end
    end

    # swap left pointer with pivot
    swap(left_pointer, pivot_position)
    return left_pointer
  end

  def swap(pointer_1, pointer_2)
    temp_value = @array[pointer_1]
    @array[pointer_1] = @array[pointer_2]
    @array[pointer_2] = temp_value
  end
end

def quicksort!(left_index, right_index)
  # base case: subarray has 0 or 1
  if right_index - left_index <= 0
    return
  end
  # partition array and grab position of pivot
  pivot_position = partition!(left_index, right_index)
  quicksort!(left_index, pivot_position - 1)
  quicksort!(pivot_position + 1, right_index)
end

array = [0, 5, 2, 1, 6, 3]
sortable_array = SortableArray.new(array)
sortable_array.quicksort!(0, array.length - 1)
p sortable_array.array
 #+END_SRC

** Selection Sort

 Run through the whole list to select the highest/lowest, and repeat /n/ times.

 Define a mutable ~sorted~ array. Loop through the array, each time popping one "sorted" element (e.g. smallest), and appending it to ~sorted~. The sorting function returns the index indicating the smallest element.

*** python

 #+BEGIN_SRC python
def findSmallest(arr):
  smallest = arr[0]
  smallest_index = 0
  for i in range(1, len(arr)):
    if arr[i] < smallest:
      smallest = arr[i]
      smallest_index = i
  return smallest_index

def selectionSort(arr):
  newArr = []
  for i in range(len(arr)):
    smallest = findSmallest(arr)
    newArr.append(arr.pop(smallest))
  return newArr
 #+END_SRC

*** javascript

 #+BEGIN_SRC js
  // array to sort
  var array = [9, 2, 5, 6, 4, 3, 7, 10, 1, 8];

  // swap function helper
  function swap(array, i, j) {
    var temp = array[i];
    array[i] = array[j];
    array[j] = temp;
  }

  function selectionSort(array) {
    for(var i = 0; i < array.length; i++) {
      var min = i;
      for(var j = i + 1; j < array.length; j++) {
        if(array[j] < array[min]) {
          min = j;
        }
      }
      if(i !== min) {
        swap(array, i, min);
      }
    }
    return array;
  }

  console.log(selectionSort(array));
 #+END_SRC

 #+RESULTS:
 : [1 (\, 2) (\, 3) (\, 4) (\, 5) (\, 6) (\, 7) (\, 8) (\, 9) (\, 10)]

* Code
** Add numbers recursively

#+BEGIN_SRC python
def sum(arr):
  total = 0
  for x in arr:
    total += x
  return total

def rAdd(arr):
  if (arr.length > 1):
    rAdd(arr.pop + arr)
  return arr
#+END_SRC

** Expression Problem

coined by Philip Wadler in an email, Bell Labs, 1998 ([[https://www.ibm.com/developerworks/java/library/j-clojure-protocols/?ca=drs-#expression][ref]])

http://www.daimi.au.dk/~madst/ecoop04/main.pdf

#+BEGIN_QUOTE
The expression problem (aka the extensibility problem)  refers to a fundamental dilemma of programming: To which degree can your application be structured in such a way that both the data model and the set of virtual operations over it can be extended without the need to modify existing code, without the need for code repetition and without runtime type errors.
#+END_QUOTE

[[https://www.ibm.com/developerworks/java/library/j-clojure-protocols/?ca=drs][Solving the Expression Problem with Clojure 1.2]], by Stuart Sierra

** Factorial
*** clojure

**** loop

#+BEGIN_SRC clojure
(defn factorial-loop [n]
  (loop [x n, k 1]
    (if (zero? x)
      k
      (recur (dec x) (* k x)))))
#+END_SRC

**** reduce

#+BEGIN_SRC clojure
(defn factorial-reduce [n]
  (reduce * (map inc (range n))))

;; or

(defn f3 [n]
  (reduce * (range 1 (inc n))))
#+END_SRC

*** common lisp

#+BEGIN_SRC lisp
(defun fact (n)
  (if (zerop n) 1
      (* n (fact (1- n)))))
#+END_SRC
*** emacs lisp

#+BEGIN_SRC emacs-lisp
(defun fact (n)
  (if (zerop n) 1
    (* n (fact2 (1- n)))))
#+END_SRC

*** js

#+BEGIN_SRC js
function fac(n) {
  if (n === 0 || n === 1) {
    return n
  } else {
    return n * fac(n - 1)
  }
)
#+END_SRC

*** Pascal

from Data Structures and Algorithms, Aho, Hopcroft, Ullman (1987).

#+BEGIN_SRC pascal
function fact (n: integer) : integer;
  Begin
    If N <= 1 Then
      return(1)
    Else
      return(n * fact(n - 1))
  End; { fact }
#+END_SRC

*** python

#+BEGIN_SRC python
def fac(n):
  if (n == 0):
    return 1
  else:
    return n * fac(n - 1)
#+END_SRC

*** scheme

#+BEGIN_SRC scheme
(define (fac n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (* n (fac (- n 1))))))
#+END_SRC

#+BEGIN_SRC scheme
(define (fac2 n)
  (define (fac-iter count acc)
    (if (= count 0)
        acc
        (fac-iter (- count 1) (* acc count))))
  (fac-iter n 1))
#+END_SRC

*** sml

#+BEGIN_SRC sml
fun factiter(count : int, acc : int) =
    if count=0
    then acc
    else factiter(count-1, acc * count);

fun fact2(x : int) =
    factiter(x, 1);

fun fact(x : int) =
    if x=0
    then 1
    else x * fact(x - 1);
#+END_SRC

** Fahrenheit to Celsius

#+BEGIN_SRC c
int main(void)
{
  float fahrenheit, celsius;

  printf("Enter Fahrenheit: ");
  scanf("%f", &fahrenheit);

  celsius = (fahrenheit - FREEZING_PT) * SCALE_FACTOR;

  printf("Calesius equivalent: %.1f\n", celsius);

  return 0;
}

#+END_SRC
** Fibonacci
*** clojure

#+BEGIN_SRC clojure
(defn fib [n]
 (loop [a 0 b 1 i n]
   (if (zero? i)
     a
     (recur b (+ a b) (dec i)))))

(defn fib2
  ([n] (fib2 0 1 n))
  ([a b n]
   (if (zero? n)
     a
     (fib2 b (+ a b) (dec n)))))

(defn fib4 [n]
  (cond (= n 0) 0
        (= n 1) 1
        :else
        (+ (fib4 (dec n))
           (fib4 (- n 2)))))
#+END_SRC

#+BEGIN_SRC clojure
;; lazy infinite sequence
(def fibs (cons 0 (cons 1 (lazy-seq (map +' fibs (rest fibs))))))

;; list of first 10 Fibonacci numbers taken from infinite sequence
(take 10 fibs)
#+END_SRC

*** js

#+BEGIN_SRC js
function fib(n) {
  if (n === 0 || n === 1) {
    return n
  } else {
    return fib(n - 1) + fib(n - 2)
  }
#+END_SRC

#+BEGIN_SRC js
const fibIter = (a, b, n) => {
  if (n === 0) {
    return b
  } else {
    return fibIter(a + b, a, n - 1)
  }

function fib2(n) {
  return fibIter(1, 1, n)
#+END_SRC

*** python

#+BEGIN_SRC python
def fib(n, first = 0, second = 1):
  for _ in range(n):
    first, second = second, first + second
  return second
#+END_SRC

#+BEGIN_SRC python
def fib2(n):
  def fibi(a, b, n):
    if n == 0:
      return b
    else:
      return fibi(a + b, a, n - 1)
  return fibi(1, 1, n)
#+END_SRC

*** scheme

#+BEGIN_SRC scheme
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
#+END_SRC

#+BEGIN_SRC scheme
(define (fib n)
  (define (fib-iter a b count)
    (if (= count 0)
        b
        (fib-iter (+ a b) a (- count 1))))
  (fib-iter 1 1 n))
#+END_SRC

** Greatest Common Denominator (GCD)

naive:

#+begin_src clojure
(s/fdef gcd
  :args (s/cat :a number? :b number?)
  :ret number?)

(defn gcd [a b]
  (loop [a a b b n 1 x nil]
    (cond (n a) x
          (and (= (rem a n) 0)
               (= (rem b n) 0)) (recur a b (inc n) n)
          :else (recur a b (inc n) x))))
#+end_src

*** [[https://mitpress.mit.edu/books/structure-and-interpretation-computer-programs][Structure and Interpretation of Computer Programs]], Abelson and Sussman

Euclid's algorithm: GCD(a, b) = GCD(b, r)

#+begin_src scheme
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
#+end_src

#+begin_src clojure
(defn gcd [a b]
  (if (zero? b)
    a
    (recur b (rem a b))))
#+end_src

*** [[https://www.cambridge.org/core/books/ml-for-the-working-programmer/BDAAF5C30634CC39385F75C97274BFCC][ML for the Working Programmer]], L.C. Paulson

gcd(0, n) = n
gcd(m, n) = gcd(n mod m, m) for m > 0

#+begin_src sml
fun gcd(m, n) =
    if m=0 then n
    else gcd(n rem n, m);
#+end_src

imperative

#+begin_src pascal
function gcd(m, n: integer): integer;
  var prevm: integer;
begin
  while m<>0 do
    begin prevm := m; m := n mod m; n := prevm end;
  gcd := n
end;
#+end_src

** Prime numbers

find primes ([[https://www.sitepoint.com/functional-reactive-programming-rxjs/][ref]])

#+BEGIN_SRC js
function (start, end) {
  var n = start - 1;

  while (n++ < end) {
    var k = Math.sqrt(n);
    var found = false;

    for (var i = 2; !found && i <= k; ++i) {
      found = n % i === 0;
    }

    if (!found) {
      return n;
    }
  }
}
#+END_SRC

*** Sieve of Eratosthenes

from https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Pseudocode

pseudo code:

#+BEGIN_QUOTE
Input: an integer n > 1.

 Let A be an array of Boolean values, indexed by integers 2 to n,
 initially all set to true.

 for i = 2, 3, 4, ..., not exceeding √n:
   if A[i] is true:
     for j = i2, i2+i, i2+2i, i2+3i, ..., not exceeding n:
       A[j] := false.

 Output: all i such that A[i] is true.
#+END_QUOTE

** Recursion

[[https://sarabander.github.io/sicp/html/1_002e2.xhtml#g_t1_002e2_002e1][SICP]]

#+BEGIN_QUOTE
linear recursive process - ...the length of the chain of deferred multiplications, and hence the amount of information needed to keep track of it, grows linearly with ~n~.
#+END_QUOTE

#+BEGIN_QUOTE
linear iterative process - In computing ~n!~, the number of steps required grows linearly with ~n~.

The contrast between the two processes can be seen in another way. In the iterative case, the program variables provide a complete description of the state of the process at any point.
#+END_QUOTE

Iterative processes execute in constant space.

*** Exercise 1.9                                                 :no_export:

Each of the following two procedures defines a method for adding two positive integers in terms of the procedures inc, which increments its argument by 1, and dec, which decrements its argument by 1.

#+BEGIN_SRC scheme
(define (+ a b)
  (if (= a 0)
      b
      (inc (+ (dec a) b))))

(define (+ a b)
  (if (= a 0)
      b
      (+ (dec a) (inc b))))
#+END_SRC

Using the substitution model, illustrate the process generated by each procedure in evaluating (+ 4 5). Are these processes iterative or recursive?

** Square Root

* Data
** books
*** [[https://dataintensive.net/][Designing Data-Intensive Applications]], by [[https://martin.kleppmann.com/][Martin Kleppmann]]

#+BEGIN_QUOTE
In an ideal world, the running time of a batch job is the size of the dataset divided by the throughput. testz  In practice, the running time is often longer, due to skew (data not being spread evenly across worker processes) and needing to wait for the slowest task to compete.
#+END_QUOTE

Impedance mismatch (borrowed from electronics) - ...an awkward translation layer is required between the objects in the application code and the database model of tables, rows, and columns.

#+BEGIN_QUOTE
As a rule of thumb, if you're duplicating values that could be stored in just one place, the schema is not normalized.
#+END_QUOTE

#+BEGIN_QUOTE
Even CODASYL committee members admitted that this was like navigating around an [n]-dimensional data space.

cited Charles W. Bachman: "the Programmer as Navigator," Communications of the ACM, volume 16, number 11, pages 653-658, November 1973
#+END_QUOTE
** databases
*** couch

http://couchdb.apache.org/

Getting started docs]]

Web access: http://127.0.0.1:5984/_utils/

#+BEGIN_SRC sh
# running?
curl http://127.0.0.1:5984/

# list dbs
curl -X GET http://127.0.0.1:5984/_all_dbs

# create db
curl -X PUT http://127.0.0.1:5984/baseball
#+END_SRC

** graphQL

reference

Example GraphQL SDL syntax data model:

#+BEGIN_SRC sh
type User {
  id: ID! @unique
  email: String @unique
  name: String!
  posts: [Post!]!
}

type Post {
  id: ID! @unique
  title: String!
  published: Boolean! @default(value: "false")
  author: User
}
#+END_SRC

*** Apollo

[[https://codesandbox.io/s/r5qp83z0yq][demo app]]

[[https://www.apollographql.com/docs/react/essentials/queries.html][queries]]

*** reference

[[https://graphql.github.io/learn/queries/][Queries and Mutations]]

#+BEGIN_SRC  gql
{
  human(id: "1000") {
    name
    height(unit: FOOT)
  }
}
#+END_SRC

aliases:

#+BEGIN_SRC gql
{
  empireHero: hero(episode: EMPIRE) {
    name
  }
  jediHero: hero(episode: JEDI) {
    name
  }
}
#+END_SRC

fragments:

#+BEGIN_SRC gql

#+END_SRC

** misc
*** identification schemes/object identification

| DOI  | Digital Object Identifier           | ISO |
| URL  | Uniform Resource Locator            |     |
| ISBN | International Standard Book Number  |     |
| GUID | Globally Unique Identifier          |     |
| PURL | Persistent Uniform Resource Locator |     |
| URN  | Uniform Resource Name               |     |


*** SDL - Schema Definition Language

 A "schema definition" specifies a schema. The definitions are sometimes referred to as IDL or SDL. [ref](https://www.graph.cool/docs/faq/graphql-idl-schema-definition-language-kr84dktnp0/)

 SDL - Schema Definition Language

 IDL ([[https://en.wikipedia.org/wiki/Interface_description_language][interface description language)]] - API spec

** Structures
*** Graphs

- adjacency list
- adjacency matrix
- incidence matrix

*** Lists
**** Data Structures and Algorithms, Aho, Hopcroft, Ullman.

 Operations:

 - ~INSERT(x, p, L)~
 - ~LOCATE(x, L)~
 - ~RETRIEVE(p, L)~
 - ~DELETE(p, L)~
 - ~NEXT(p, L)~
 - ~MAKENULL(L)~
 - ~FIRST(L)~
 - ~PRINTLIST(L)~

 Example program, independent of list representation:

 > p will be the "current" position in L, and q will move ahead to find equal elements

 #+BEGIN_SRC pascal
procedure PURGE ( var L: LIST );
  { PURGE removes duplicate elements from list L }
  var
     p, q: position;
  begin
     p := FIRST(L);
     while p <> END(L) do begin
        q := NEXT(p, L);
        while q <> END(L) do
          if same(RETRIEVE(p, L), RETRIEVE(q, L))
             then DELETE(q, L)
          else
             q := NEXT(q, L);
        p := NEXT(p, L)
      end
end; { PURGE }
 #+END_SRC

***** Array implementation

 > Define the type ~LIST~ to be a record having two fields. The first field is an array of elements whose length is sufficient to hold the maximum size list that will be encountered. The second field is an integer ~last~ indicating the position of the last list element in the array.

 #+BEGIN_SRC pascal
const maxlength = 100; { some suitable constant }
type
   LIST = record
             elements : array[1...maxlength] of elementtype;
             last     : integer
          end;
          position =  integer;
function END ( var L: LIST ): position;
begin
   return (L.last + 1)
end; { END }
 #+END_SRC

 > INSERT moves the elements at location ~p~, ~p+1~, …, ~last~ into locations ~p+1~, ~p+2~, …, ~last+1~ and then inserts the new element at location ~p~.

 #+BEGIN_SRC pascal
procedure INSERT ( x: elementtype; p: position; var L: LIST);
{ INSERT places x at position p in list L }
var
   q :  position;
   begin
      if L.last >= maxlength thne
         error('listi s full')
      else if (p > L.last + 1) or (p < 1) then
         error('position does not exist')
         else begin
            for q := L.las downto p do
               {shift elements at p, p+1, ... down one position }
               L.elements[q + 1] := L.elements[q];
            L.last := L.loast + 1;
            L.elements[p] := x
            end
   end; { INSERT }
 #+END_SRC

 > DELETE removes the element at position ~p~ by moving the elements at positions ~p+1~, ~p+2~, …, ~last~ into position ~p~, ~p+1~, …, ~last-1~.

 #+BEGIN_SRC pascal
procedure DELEETE ( p: position; var L: LIST) ;
{ DELETE removes the element at position p of list L }
var
   q :  position;
begin
    if (p > L.last) or (p < l) then
      error('position does not exist')
    else begin
         L.last := L.last - 1;
         for q := p to L.last do
            { shift elements at p+1, p+2, . . . up on poistion }
            L.elements[q] := L.elements[q+1]
    end
end; { DELETE }
 #+END_SRC

 > LOCATE sequentially scans the array to look for a given element. If the element is not found, LOCATE returns ~last+1~.

 #+BEGIN_SRC pascal
function LOCATE ( x: elemenettype; L: LIST ): position;
{ LOCATE returns the position of x on list L }
  var
      q :  position;
  begin
      for q := 1 to L.last do
          if L.elements[q] = x then
            return(q);
      return (L.last + 1) { if not found }
  end; { LOCATE }
 #+END_SRC

***** Pointer
***** Cursor
*** Trees
**** Red Black Trees

 http://www.eternallyconfuzzled.com/tuts/datastructures/jsw_tut_rbtree.aspx, Julienne Walker
* Functional Programming
** Lambda Calculus
*** combinators

[[http://www.madore.org/~david/programs/unlambda/][Unlambda]] uses S, K, and I

*** reference

[[https://github.com/tadeuzagallo/lc-js][lc-js: A λ-calculus interpreter written in JavaScript]]

[[https://tadeuzagallo.com/blog/writing-a-lambda-calculus-interpreter-in-javascript/][A λ-calculus interpreter]]

** Misc
* Lisp (general)

[[https://www.dreamsongs.com/Books.html][Richard Gabriel's writings]]

* Misc :noexport:
** Bayes Rule

** calculate digits of pi

from https://www.youtube.com/watch?time_continue=329&v=VADudzQGvU8

#+BEGIN_SRC TECO
GZOJ\UNQN"E 40UN ' BUH BUV HK
QN< J BUQ QN*10/3UI
QI< \+2*10+(QQ*QI)UA B L K QI*2-1UJ QA/QJUQ
QA-(QQ*QJ)-2\ 10@I// -1\%I >
QQ/10UT QH+QT+48UW QW-58"E 48UW \%V ' QV"N QV
QV^T @^A\
/HKEX$$
#+END_SRC

** circle → triangle → square :noexport:

#+BEGIN_SRC lisp
(setq big-area 2)
(setq small-area 1)

(defun radius-from-area (x)
  (sqrt (/ x pi)))

(setq big-r (radius-from-area big-area))
(setq small-r (radius-from-area small-area))

(setq a (+ small-r big-r))
(setq b (- big-r small-r))
(defun hypotenuse (a b)
  (sqrt (+ (* a a) (* b b))))
(setq c (hypotenuse a b))

(setq d (atan (/ b a)))

(setq e (+ a big-r))

(setq f (* e (tan d)))

(setq g (+ f small-r))

(setq h (* 2 g))

(setq i (* h h))
#+END_SRC

#+BEGIN_SRC lisp
(setq big-r 2)
(setq small-r 1)

(setq a (+ small-r big-r))
(setq b (- big-r small-r))
(defun hypotenuse (a b)
  (sqrt (+ (* a a) (* b b))))
(setq c (hypotenuse a b))

(setq d (atan (/ b a)))

(setq e (+ a big-r))

(setq f (* e (tan d)))

(setq g (+ f small-r))

(setq h (* 2 g))

(setq i (* h h))
#+END_SRC

* Reactive/dataflow :noexport:

Suffixing observable names with `$` comes from cycle.js: https://cycle.js.org/basic-examples.html#basic-examples-increment-a-counter-what-is-the-convention
* Streams

** reference

- https://github.com/substack/stream-handbook
- https://nodejs.org/api/stream.html

* Types :noexport:

** ADTs

[[https://swsnr.de/blog/2018/02/24/algebraic-data-types-in-scala/][Algebraic Data Types In Scala]], by [[https://github.com/lunaryorn][Sebastian Wiesner]]

** gradual typing

[[https://link.springer.com/chapter/10.1007%252F978-3-540-73589-2_2][Gradual Typing for Objects]]

Abstract:

> Static and dynamic type systems have well-known strengths and weaknesses. In previous work we developed a gradual type system for a functional calculus named 𝜆?→. Gradual typing provides the benefits of both static and dynamic checking in a single language by allowing the programmer to control whether a portion of the program is type checked at compile-time or run-time by adding or removing type annotations on variables. Several object-oriented scripting languages are preparing to add static checking. To support that work this paper develops 𝐎𝐛?<:, a gradual type system for object-based languages, extending the Ob < : calculus of Abadi and Cardelli. Our primary contribution is to show that gradual typing and subtyping are orthogonal and can be combined in a principled fashion. We also develop a small-step semantics, provide a machine-checked proof of type safety, and improve the space efficiency of higher-order casts.
