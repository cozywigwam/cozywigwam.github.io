#+OPTIONS: toc:nil -:nil H:6 ^:nil
#+EXCLUDE_TAGS: noexport
#+BEGIN_EXAMPLE
---
title: "Lisp"
layout: notation
description: More Parens
path: "/lisp/"
---
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
(setq x 3)
#+END_SRC


* Special forms
** setq

#+BEGIN_EXAMPLE
setq is a special form in ‘C source code’.

(setq [SYM VAL]...)

Set each SYM to the value of its VAL.
The symbols SYM are variables; they are literal (not evaluated).
The values VAL are expressions; they are evaluated.
Thus, (setq x (1+ y)) sets ‘x’ to the value of ‘(1+ y)’.
The second VAL is not computed until after the first SYM is set, and so on;
each VAL can use the new value of variables set earlier in the ‘setq’.
The return value of the ‘setq’ form is the value of the last VAL.

[back]
#+END_EXAMPLE

* Dialects
** Clojure

*** Data Structures

| Maps    | ~{:id 1 :name "test"}~      |
| Vectors | ~[1 2 3]~                   |
| Lists   | ~'(1 2 3)~                  |
| Sets    | ~#{:a "apple" :b "banana"}~ |

**** Vectors

[[https://hypirion.com/musings/understanding-persistent-vector-pt-1][Understanding Clojure's Persistent Vectors, pt. 1]], by [[https://github.com/hyPiRion][Jean Niklas L’orange]]

*** Leiningen

[[https://github.com/technomancy/leiningen/blob/master/sample.project.clj][options]]

To go to existing namespace:

#+BEGIN_SRC clojure
(load "my_project/core")

;; then

(in-ns 'my-project.core)
#+END_SRC

Or in ~project.clj~:

#+BEGIN_SRC clojure
:repl-options {:init-ns my-project.core}
#+END_SRC

*** misc

**** for

#+BEGIN_SRC clojure
(def a {:x 1 :y 2})
(:x a)

(def as [a a])
(for [{n :x} as] n)
(for [{n :x} as :let [x (:x n) y (:y n)]] n)
(for [{n :x} as :let [{x :x} n) {y :y} n]] n)

(for [word ["blah" "other"]] (format "%s" word)

(for [x (:edges @app-state)] (:name (:a-component x)))

(for [{x :a-component} (:edges @app-state)] x)


#+END_SRC

[[http://clojure-doc.org/articles/cookbooks/files_and_directories.html][Recipes]]

**** transducers

[[http://clj-me.cgrand.net/2014/10/08/these-arent-the-reducing-functions-you-are-looking-for/][These aren’t the reducing functions you are looking for]], by [[https://github.com/cgrand][Christophe Grand]]

*** nREPL

https://nrepl.readthedocs.io/en/latest/design/

> nREPL largely consists of three abstractions: handlers, middleware, and transports. These are roughly analogous to the handlers, middleware, and adapters of Ring, though there are some important semantic differences. Finally, nREPL is fundamentally message-oriented and asynchronous (in contrast to most REPLs that build on top of streams provided by e.g. terminals).

> ~id~ is for tracking a single message, and ~sessions~ are for tracking remote state

~*nrepl-messages*~ nREPL requests & responses

| ~C-c M-d~ | ~cider-describe-connection~ |

*** reference

- [[http://www.4clojure.com/][4Clojure]]
- [[https://clojure.org/api/cheatsheet][API Cheatsheet]]
- [[https://en.wikibooks.org/wiki/Learning_Clojure/Data_Structures][WikiBooks Learning Clojure Data Structure]]
- [[https://github.com/clojure-cookbook/clojure-cookbook][Clojure Cookbook github]]

** Common Lisp

*** reference

[[http://stevelosh.com/blog/2018/08/a-road-to-common-lisp/][A Road to Common Lisp]], by [[https://twitter.com/stevelosh][Steve Losh]]

[[http://www.lispworks.com/documentation/lw70/CLHS/Front/Contents.htm][Common Lisp HyperSpec]]

** Scheme
*** misc

 ~(environment-bound? (nearest-repl/environment) 'is-this-defined)~

*** debugging

| ? | help, list command letters                                               |
| A | show All bindings in current environment and its ancestors               |
| B | move (Back) to next reduction (earlier in time)                          |
| C | show bindings of identifiers in the Current environment                  |
| D | move (Down) to the previous subproblem (later in time)                   |
| E | Enter a read-eval-print loop in the current environment                  |
| F | move (Forward) to previous reduction (later in time)                     |
| G | Go to a particular subproblem                                            |
| H | prints a summary (History) of all subproblems                            |
| I | redisplay the error message Info                                         |
| J | return TO the current subproblem with a value                            |
| K | continue the program using a standard restart option                     |
| L | (List expression) pretty print the current expression                    |
| M | (Frame elements) show the contents of the stack frame, in raw form       |
| O | pretty print the procedure that created the current environment          |
| P | move to environment that is Parent of current environment                |
| Q | Quit (exit debugger)                                                     |
| R | print the execution history (Reductions) of the current subproblem level |
| S | move to child of current environment (in current chain)                  |
| T | print the current subproblem or reduction                                |
| U | move (Up) to the next subproblem (earlier in time)                       |
| V | eValuate expression in current environment                               |
| W | enter environment inspector (Where) on the current environment           |
| X | create a read eval print loop in the debugger environment                |
| Y | display the current stack frame                                          |
| Z | return FROM the current subproblem with a value                          |

*** reference

[[https://www.gnu.org/software/mit-scheme/documentation/mit-scheme-user/][MIT/GNY Scheme 9.4 documentation]]

[[http://www.neilvandyke.org/quack/quack.el][quack.el]]

[[https://groups.csail.mit.edu/mac/users/gjs/6.945/dont-panic/][Don't Panic!]] by rlm, larsj re debugging

* Misc

[[https://www.dreamsongs.com/Books.html][Richard Gabriel's writings]]
