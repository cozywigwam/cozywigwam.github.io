#+OPTIONS: toc:nil -:nil H:6 ^:nil
#+EXCLUDE_TAGS: noexport
#+BEGIN_EXAMPLE
---
title: "Lisp"
layout: notation
description: More Parens
path: "/lisp/"
---
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
(setq x 3)
#+END_SRC


* Special forms
** setq

#+BEGIN_EXAMPLE
setq is a special form in ‘C source code’.

(setq [SYM VAL]...)

Set each SYM to the value of its VAL.
The symbols SYM are variables; they are literal (not evaluated).
The values VAL are expressions; they are evaluated.
Thus, (setq x (1+ y)) sets ‘x’ to the value of ‘(1+ y)’.
The second VAL is not computed until after the first SYM is set, and so on;
each VAL can use the new value of variables set earlier in the ‘setq’.
The return value of the ‘setq’ form is the value of the last VAL.

[back]
#+END_EXAMPLE

* Dialects
** Clojure
*** Data Structures

| Maps    | ~{:id 1 :name "test"}~      |
| Vectors | ~[1 2 3]~                   |
| Lists   | ~'(1 2 3)~                  |
| Sets    | ~#{:a "apple" :b "banana"}~ |

**** Vectors

[[https://hypirion.com/musings/understanding-persistent-vector-pt-1][Understanding Clojure's Persistent Vectors, pt. 1]], by [[https://github.com/hyPiRion][Jean Niklas L’orange]]

*** Leiningen

[[https://github.com/technomancy/leiningen/blob/master/sample.project.clj][options]]

To go to existing namespace:

#+BEGIN_SRC clojure
(load "my_project/core")

;; then

(in-ns 'my-project.core)
#+END_SRC

Or in ~project.clj~:

#+BEGIN_SRC clojure
:repl-options {:init-ns my-project.core}
#+END_SRC

*** libraries
**** Quil

***** reference

- [[http://nbeloglazov.com/2014/05/29/quil-intro.html][Quil Intro]], by [[https://github.com/nbeloglazov][Nikita Beloglazov]]
- [[http://quil.info/api][API]]
- [[http://quil.info/sketches/create][Create]]
- [[https://github.com/quil/quil/wiki][Wiki]]
- [[https://github.com/yogthos/quil-reagent-demo][quil-reagent-demo]]

*** misc
**** constants

Use ~:const~ metadata tag ([[https://clojurefun.wordpress.com/2012/08/14/performance-tip-defining-constants/][ref]]):

#+BEGIN_SRC clojure
def ^:const avoid-reflection 10)
#+END_SRC

> As is commonly the case, the biggest performance win in Clojure comes from avoiding reflection.

**** for

#+BEGIN_SRC clojure
(def a {:x 1 :y 2})
(:x a)

(def as [a a])
(for [{n :x} as] n)
(for [{n :x} as :let [x (:x n) y (:y n)]] n)
(for [{n :x} as :let [{x :x} n) {y :y} n]] n)

(for [word ["blah" "other"]] (format "%s" word)

(for [x (:edges @app-state)] (:name (:a-component x)))

(for [{x :a-component} (:edges @app-state)] x)


#+END_SRC

[[http://clojure-doc.org/articles/cookbooks/files_and_directories.html][Recipes]]

**** Quil

[[https://github.com/quil/quil][github]]

[[http://www.tylerlhobbs.com/writings/using-quil-for-artwork][Using Quil for Artwork]], by Tyler Hobbs

**** style guides

- [[https://dev.clojure.org/display/community/Library+Coding+Standards][Clojure Community - Library Coding Standards]]
- [[https://github.com/bbatsov/clojure-style-guide][The Clojure Style Guide]], by [[https://twitter.com/bbatsov][Bozhidar Batsov]]

#+BEGIN_QUOTE
Use seq as a terminating condition to test whether a sequence is empty (this technique is sometimes called nil punning). [link]
#+END_QUOTE

#+BEGIN_SRC clojure
;; good
(defn print-seq [s]
  (when (seq s)
    (prn (first s))
    (recur (rest s))))

;; bad
(defn print-seq [s]
  (when-not (empty? s)
    (prn (first s))
    (recur (rest s))))
#+END_SRC

Other misc:

#+BEGIN_SRC clojure
;; good
(if-let [result (foo x)]
  (something-with result)
  (something-else))

;; good
(when-let [result (foo x)]
  (do-something-with result)
  (do-something-more-with result))

;; good
(if-not pred
  (foo))

;; good
(not= foo bar)

;; bad
(not (= foo bar))

;; good
(< 5 x 10)

;; bad
(and (> x 5) (< x 10))

;; good
(filter even? (range 1 10))

;; bad
(filter #(even? %) (range 1 10))

;; good
(filter (complement some-pred?) coll)

;; bad
(filter #(not (some-pred? %)) coll)

;; Assuming `(:require [clojure.string :as str])`...

;; good
(map #(str/capitalize (str/trim %)) ["top " " test "])

;; better
(map (comp str/capitalize str/trim) ["top " " test "])

;; good
(map #(+ 5 %) (range 1 10))

;; (arguably) better
(map (partial + 5) (range 1 10))

;; good
(-> [1 2 3]
    reverse
    (conj 4)
    prn)

;; not as good
(prn (conj (reverse [1 2 3])
           4))

;; good
(->> (range 1 10)
     (filter even?)
     (map (partial * 2)))

;; not as good
(map (partial * 2)
     (filter even? (range 1 10)))

;; good
(cond
  (= x 10) :ten
  (= x 20) :twenty
  (= x 30) :thirty
  :else :dunno)

;; much better
(condp = x
  10 :ten
  20 :twenty
  30 :thirty
  :dunno)

;; best
(case x
  10 :ten
  20 :twenty
  30 :forty
  :dunno)

;; good
(def ^:private a 5)

;; bad
(def ^{:private true} a 5)

;; good
(defn- private-fun [] ...)

(def ^:private private-var ...)

;; bad
(defn private-fun [] ...) ; not private at all

(defn ^:private private-fun [] ...) ; overly verbose

(def private-var ...) ; not private at all

;; good
(defn f->c ...)

;; not so good
(defn f-to-c ...)

;; good
(let [[a b _ c] [1 2 3 4]]
  (println a b c))

(dotimes [_ 3]
  (println "Hello!"))

;; bad
(let [[a b c d] [1 2 3 4]]
  (println a b d))

(dotimes [i 3]
  (println "Hello!"))

;; good
(defn frobnitz
  "This function does a frobnitz.
  It will do gnorwatz to achieve this, but only under certain
  circumstances."
  []
  ...)

;; bad
(defn frobnitz
  "This function does a frobnitz. It will do gnorwatz to
  achieve this, but only under certain circumstances."
  []
  ...)

;; good
(defn foo
  "docstring"
  [x]
  (bar x))

;; bad
(defn foo [x]
  "docstring"
  (bar x))
#+END_SRC

- Use ~lisp-case~ for function and variable names.
- Use ~CamelCase~ for protocols, records, structs, and types. (Keep acronyms like HTTP, RFC, XML uppercase.)

Follow clojure.core's example for idiomatic names like pred and coll.

functions:

| ~f~, ~g~, ~h~ | function input               |
| ~n~           | integer input usually a size |
| ~index~, ~i~  | integer index                |
| ~x~, ~y~      | numbers                      |
| ~xs~          | sequence                     |
| ~m~           | map                          |
| ~s~           | string input                 |
| ~re~          | regular expression           |
| ~coll~        | a collection                 |
| ~pred~        | a predicate closure          |
| ~& more~      | variadic input               |
| ~xf~          | xform, a transducer          |

macros:

| ~expr~    | an expression          |
| ~body~    | a macro body           |
| ~binding~ | a macro binding vector |

> Avoid writing comments to explain bad code. Refactor the code to make it self-explanatory.

| ~TODO~     |
| ~FIXME~    |
| ~OPTIMIZE~ |
| ~HACK~     |
| ~REVIEW~   |

**** transducers

[[http://clj-me.cgrand.net/2014/10/08/these-arent-the-reducing-functions-you-are-looking-for/][These aren’t the reducing functions you are looking for]], by [[https://github.com/cgrand][Christophe Grand]]

*** nREPL

https://nrepl.readthedocs.io/en/latest/design/

> nREPL largely consists of three abstractions: handlers, middleware, and transports. These are roughly analogous to the handlers, middleware, and adapters of Ring, though there are some important semantic differences. Finally, nREPL is fundamentally message-oriented and asynchronous (in contrast to most REPLs that build on top of streams provided by e.g. terminals).

> ~id~ is for tracking a single message, and ~sessions~ are for tracking remote state

~*nrepl-messages*~ nREPL requests & responses

| ~C-c M-d~ | ~cider-describe-connection~ |

*** reference

- [[http://www.4clojure.com/][4Clojure]]
- [[https://clojure.org/api/cheatsheet][API Cheatsheet]]
- [[https://en.wikibooks.org/wiki/Learning_Clojure/Data_Structures][WikiBooks Learning Clojure Data Structure]]
- [[https://github.com/clojure-cookbook/clojure-cookbook][Clojure Cookbook github]]

** Common Lisp
*** books
**** Common Lisp, by David Touretsky

***** EVAL notation

Eval rules:
- symbols -> their variable's value
- T, NIL -> T, NIL
- numbers -> themselves
- lists (non special forms) -> func arg & args

*** Truth, Falsehood, and Equality

from [[https://www.apress.com/us/book/9781590592397][Practical Common Lisp]] by [[http://www.gigamonkeys.com/][Peter Siebel]]

~NIL~ is both an atom and a list

> Using the empty list as false is a reflection o Lisp's heritage as a list-processing language much as the use of the integer 0 as false in C is a reflection of its heritage as a bit-twiddling language.

Scheme's ~#f~, ~nil~, and ~()~ are all distinct. CL's ~NIL~ and ~()~ are "completely interchangeable."

> And because ~NIL~... is the name of a constant variable with the symbol ~NIL~ as its value, the expressions ~nil~, ~()~, ~'nil~, and ~'()~ all evaluate to the same thing—the unquoted forms are evaluated as a reference to the constant variable whose value is the symbol ~NIL~, but in the quoted forms the ~QUOTE~ special operator evaluates to the symbol directly. For he same reason, both ~t~ and ~'t~ will evaluate to the same thing: the symbol ~T~.

| ~EQ~     | "object identity", do not use for numbers and characters          |
| ~EQL~    | ~EQ~ plus numbers & characters; PCL uses "'always use EQL' style" |
| ~EQUAL~  | loosens ~EQL~'s discrimination                                    |
| ~EQUALP~ | loosens more                                                      |

*** reference

[[http://stevelosh.com/blog/2018/08/a-road-to-common-lisp/][A Road to Common Lisp]], by [[https://twitter.com/stevelosh][Steve Losh]]

[[http://www.lispworks.com/documentation/lw70/CLHS/Front/Contents.htm][Common Lisp HyperSpec]]

** Scheme
*** misc

 ~(environment-bound? (nearest-repl/environment) 'is-this-defined)~

*** debugging

| ? | help, list command letters                                               |
| A | show All bindings in current environment and its ancestors               |
| B | move (Back) to next reduction (earlier in time)                          |
| C | show bindings of identifiers in the Current environment                  |
| D | move (Down) to the previous subproblem (later in time)                   |
| E | Enter a read-eval-print loop in the current environment                  |
| F | move (Forward) to previous reduction (later in time)                     |
| G | Go to a particular subproblem                                            |
| H | prints a summary (History) of all subproblems                            |
| I | redisplay the error message Info                                         |
| J | return TO the current subproblem with a value                            |
| K | continue the program using a standard restart option                     |
| L | (List expression) pretty print the current expression                    |
| M | (Frame elements) show the contents of the stack frame, in raw form       |
| O | pretty print the procedure that created the current environment          |
| P | move to environment that is Parent of current environment                |
| Q | Quit (exit debugger)                                                     |
| R | print the execution history (Reductions) of the current subproblem level |
| S | move to child of current environment (in current chain)                  |
| T | print the current subproblem or reduction                                |
| U | move (Up) to the next subproblem (earlier in time)                       |
| V | eValuate expression in current environment                               |
| W | enter environment inspector (Where) on the current environment           |
| X | create a read eval print loop in the debugger environment                |
| Y | display the current stack frame                                          |
| Z | return FROM the current subproblem with a value                          |

*** reference

[[https://www.gnu.org/software/mit-scheme/documentation/mit-scheme-user/][MIT/GNY Scheme 9.4 documentation]]

[[http://www.neilvandyke.org/quack/quack.el][quack.el]]

[[https://groups.csail.mit.edu/mac/users/gjs/6.945/dont-panic/][Don't Panic!]] by rlm, larsj re debugging

* Misc

[[https://www.dreamsongs.com/Books.html][Richard Gabriel's writings]]
