#+OPTIONS: toc:nil -:nil H:6 ^:nil
#+EXCLUDE_TAGS: noexport
#+STARTUP: overview
#+BEGIN_EXAMPLE
---
title: "Lisps"
layout: notation
description: Speaking Parenthetically
path: "/lisps/"
---
#+END_EXAMPLE

* Clojure
** Data Structures

| Maps    | ~{:id 1 :name "test"}~      |
| Vectors | ~[1 2 3]~                   |
| Lists   | ~'(1 2 3)~                  |
| Sets    | ~#{:a "apple" :b "banana"}~ |

*** maps

#+BEGIN_SRC clojure
(def a {:x 1 :y 2})
(:x a)
#+END_SRC

*** Vectors

[[https://hypirion.com/musings/understanding-persistent-vector-pt-1][Understanding Clojure's Persistent Vectors, pt. 1]], by [[https://github.com/hyPiRion][Jean Niklas L’orange]]

** Datomic & DataScript

- [[http://tonsky.me/blog/datascript-internals/][A shallow dive into DataScript internals]]
- [[https://github.com/tonsky/datascript][DataScript github]]
- [[https://docs.datomic.com/on-prem/index.html][Datomic docs]]

** Extensible Data Notation (EDN)

https://github.com/edn-format/edn

** io

List ~*.md~ filenames in ~resources/public/markdown~ dir:

#+begin_src clojure
(for [^File file (seq (.listFiles (io/file (io/resource "public/markdown"))))
      :when (re-find #"md$" (.getName file))]
  (.getName file))
#+end_src

*** reference

http://clojure-doc.org/articles/cookbooks/files_and_directories.html

** machine learning

[[http://nils-blum-oeste.net/image-analysis-with-clojure-up-and-running-with-opencv/][Image analysis with Clojure and OpenCV: A face detection example]]

https://gist.github.com/nblumoe/5468625

** language
*** for                                                            :noexport:

#+BEGIN_SRC clojure
(def as [a a])
(for [{n :x} as] n)
(for [{n :x} as :let [x (:x n) y (:y n)]] n)
(for [{n :x} as :let [{x :x} n) {y :y} n]] n)

(for [word ["blah" "other"]] (format "%s" word)

(for [x (:edges @app-state)] (:name (:a-component x)))

(for [{x :a-component} (:edges @app-state)] x)
#+END_SRC

[[http://clojure-doc.org/articles/cookbooks/files_and_directories.html][Recipes]]

*** functions

(Illustration only) function as lambda binding:

#+BEGIN_SRC clojure
(def factorial
  (fn [n]
    (loop [cnt n acc 1]
      (if (zero? cnt)
        acc
        (recur (dec cnt) (* acc cnt))))))
#+END_SRC

...as opposed to ("regular"):

#+BEGIN_SRC clojure
(defn fact-defn [n]
  (loop [x n, k 1]
    (if (zero? x)
      k
      (recur (dec x) (* k x)))))
#+END_SRC

*** let

#+BEGIN_SRC clojure
(defn xab [x]
  (let [a x b x]
    {:a a :b b}))
#+END_SRC

*** namespaces

ref. https://clojure.org/reference/namespaces

- Creating and switching to a namespace: in-ns ns create-ns
- Adding to a namespace: alias def import intern refer
- Finding what namespaces exist: all-ns find-ns
- Examining a namespace: ns-name ns-aliases ns-imports ns-interns ns-map ns-publics ns-refers
- Getting a namespace from a symbol: resolve ns-resolve namespace
- Removing things: ns-unalias ns-unmap remove-ns

#+begin_src clojure
(ns-publics 'myns.core)
(ns-aliases 'myns.core)
(clojure.repl/dir myns.core)
#+end_src

*** threading

Equivalent thread and compose

#+begin_src clojure
(defn get-name [f] (.getName f))
(defn md? [f] (re-find #"md$" f))

(def files (filter #(md? (.getNme %)) (seq (.listFiles (io/file (io/resource "public/markdown"))))))
(defn remove-extension [s] (clojure.string/replace s #"\.md$" ""))

(map (comp remove-extension get-name) files)
(map #(-> % get-name remove-extension) files)
#+end_src

*** next

next vs. rest?

> Use `next' when you are definitely about to force it with `seq', `empty?', or something anyway, `rest' otherwise. `reduce' qualifies for the former.

[[https://twitter.com/S11001001][Stephen Campbell]], at https://grokbase.com/t/gg/clojure/122s341d7e/next-vs-rest-and-reduce

#+BEGIN_SRC clojure
(def very-lazy (-> (iterate #(do (print \.) (inc %)) 1) rest rest rest))
(def less-lazy (-> (iterate #(do (print \.) (inc %)) 1) next next next))

(println (first very-lazy))
(println (first less-lazy))
#+END_SRC

*** sequences

- [[http://timothypratley.blogspot.com/2017/01/reagent-deep-dive-part-3-sequences.html][Reagent deep dive part 3: Sequences]], by [[https://timothypratley.blogspot.com/p/httpswww.html][Timothy Pratley]]

*** symbols

Cannot start with a number. Otherwise alphanumeric union ~+~, ~-~, ~*~, ~/~, ~!~, ~?~, ~.~, ~_~, ~<~, ~>~, ~=~, and ~'~. ~/~, ~.~, and ~:~ have restrictions.

https://clojure.org/reference/reader

** libraries
*** figwheel-main

https://figwheel.org/

project.clj

#+begin_src clojure
:dependencies [[com.bhauman/figwheel-main "x.x.x"]
               [com.bhauman/rebel-readline-cljs "x.x.x"]]
 ;; setup target as a resource path
:resource-paths ["target" "resources"]
;; set up an alias to invoke your figwheel build
:aliases {"fig" ["trampoline" "run" "-m" "figwheel.main"]
          "build-dev" ["trampoline" "run" "-m" "figwheel.main" "-b" "dev" "-r"]
          "fig:min"   ["run" "-m" "figwheel.main" "-O" "advanced" "-bo" "dev"]
          "fig:test"  ["run" "-m" "figwheel.main" "-co" "test.cljs.edn" "-m" myns.test-runner]}}
#+end_src

dev.cljs.edn

#+begin_src clojure
{:main example.core}
#+end_src

or

#+begin_src clojure
^{:watch-dirs ["src"]
  :css-dirs ["resources/public/css"]
  :auto-testing false}
{:main sunflowerseastar.core}
#+end_src

~src/example/core.cljs~

#+begin_src clojure
(ns example.core)

(enable-console-print!)

(prn "hello world!")
#+end_src

#+begin_src sh
lein trampoline run -m figwheel.main -- -b dev -r
#+end_src

| ~-b dev~, ~--build dev~ | read ~dev.cljs.edn~ |
| ~-r~, ~--repl~          | launch REPL         |

using aliases

#+begin_src sh
lein fig -- -b dev -r
lein build-dev
lein fig:min
#+end_src

*** hiccup

style, class:

 #+begin_src clojure
(defn wrapper-component [inner]
  [:div {:style {:border "3px solid red"}} inner])
 #+end_src

*** incanter

https://github.com/incanter/incanter/wiki

https://github.com/incanter/incanter/wiki/datasets

http://incanter.org/docs/data-sorcery-light-new.pdf

https://github.com/incanter/incanter/wiki/matrices

https://github.com/incanter/incanter/wiki/sample-plots-in-incanter

https://data-sorcery.org/2010/04/14/latex/

*** Leiningen                                                      :noexport:

[[https://github.com/technomancy/leiningen/blob/master/sample.project.clj][options]]

To go to existing namespace:

#+BEGIN_SRC clojure
(load "my_project/core")

;; then

(in-ns 'my-project.core)
#+END_SRC

Or in ~project.clj~:

#+BEGIN_SRC clojure
:repl-options {:init-ns my-project.core}
#+END_SRC

User profile location: =~/.lein/profiles.clj=:

#+begin_src clojure
{:user {:plugins [[cider/cider-nrepl "0.20.0-SNAPSHOT"]]
        :dependencies [[org.clojure/test.check "0.9.0"]]}}
#+end_src

**** misc

#+begin_src sh
lein deps :tree
#+end_src

*** nREPL/cider

[[https://juxt.pro/blog/posts/nrepl.html][Overview of the nREPL – {:op "describe"}]], by Dominic Monroe

https://nrepl.readthedocs.io/en/latest/design/

> nREPL largely consists of three abstractions: handlers, middleware, and transports. These are roughly analogous to the handlers, middleware, and adapters of Ring, though there are some important semantic differences. Finally, nREPL is fundamentally message-oriented and asynchronous (in contrast to most REPLs that build on top of streams provided by e.g. terminals).

> ~id~ is for tracking a single message, and ~sessions~ are for tracking remote state

~*nrepl-messages*~ nREPL requests & responses

| ~C-c M-d~   | ~cider-describe-connection~ |
| ~SPC m s c~ | ~cider-repl-clear-buffer~   |

*** Om

**** reference

+ https://circleci.com/blog/why-we-use-om-and-why-were-excited-for-om-next/
+ https://plumatic.github.io//om-sweet-om-high-functional-frontend-engineering-with-clojurescript-and-react

*** Quil

**** reference

- [[http://nbeloglazov.com/2014/05/29/quil-intro.html][Quil Intro]], by [[https://github.com/nbeloglazov][Nikita Beloglazov]]
- [[http://quil.info/api][API]]
- [[http://quil.info/sketches/create][Create]]
- [[https://github.com/quil/quil/wiki][Wiki]]
- [[https://github.com/yogthos/quil-reagent-demo][quil-reagent-demo]]

*** secretary

https://github.com/clj-commons/secretary

**** reference

https://yogthos.net/posts/2014-08-14-Routing-With-Secretary.html

*** stylefy

#+begin_src clojure
(def button-style {:padding "1em"
                   :border "3px solid magenta"})

(defn- button [text]
  [:div (use-style button-style) text])
#+end_src

** misc
*** constants

Use ~:const~ metadata tag ([[https://clojurefun.wordpress.com/2012/08/14/performance-tip-defining-constants/][ref]]):

#+BEGIN_SRC clojure
def ^:const avoid-reflection 10)
#+END_SRC

> As is commonly the case, the biggest performance win in Clojure comes from avoiding reflection.

*** decimal to hexadecimal

#+BEGIN_SRC clojure
(require '[clojure.string :as str])

(defn b10->b16 [n]
  ((into (vec (range 0 10)) [\a \b \c \d \e \f]) n))

(defn str-rems [n]
  (if (zero? n)
    0
    (str (b10->b16 (rem n 16)) (str-rems (quot n 16)))))

(defn dec->hex [n]
  (-> n
      str-rems
      str/reverse
      (str/replace #"^0+" "")))
#+END_SRC

*** hashes with spec/gen                                           :noexport:

from https://news.ycombinator.com/item?id=18776697, found via https://twitter.com/jlongster/status/1078666653662150657

> Yes, I could show you a simple example:
>
> Let's create our own 78 digits long string type:

#+BEGIN_SRC clojure
(require '[clojure.spec.alpha :as s])

(def hex-digit (set "0123456789"))

(defn hex-digit? [x]
  (contains? hex-digit x))

(defn hex-str? [s]
  (every? hex-digit? (seq s)))

(s/def ::hash
  (s/and hex-str? #(= (count %) 78)))
#+END_SRC

> ::hash is now registered, now we go to the REPL:

#+BEGIN_SRC clojure
(s/valid? ::hash "23179372")

;;=> false

(s/valid? ::hash "nope93721907914920047210715459933122004671648400678953445710500236944435987060")

;;=> false

(s/valid? ::hash "231793721907914920047210715459933122004671648400678953445710500236944435987060")

;;=> true
#+END_SRC

> That's cool, but we want to generate too:

#+BEGIN_SRC clojure
(require '[clojure.spec.gen.alpha :as g])

(defn hex-str-gen [n]
  (let [digit (g/elements hex-digit)]
    (g/fmap clojure.string/join (g/vector digit n))))

(s/def ::hash
  (s/with-gen
    (s/and
     hex-str?
     #(= (count %) 78))
    #(hex-str-gen 78)))
#+END_SRC

> We extended our ::hash spec with a generator function, so we can do this now:

#+BEGIN_SRC clojure
(g/generate (s/gen ::hash))

;;=> "310584715385467847758653938894742415543975445356609397864862925839413265904779"
#+END_SRC

> (+ Pro tip: you could spec functions too)
>
> Learn more about spec here: https://clojure.org/guides/spec

*** hexadecimal to decimal

#+BEGIN_SRC clojure
(defn b16->b10 [n]
  ((zipmap
    (into
     (vec (flatten (map (comp sequence str) (range 0 10))))
     (seq "abcdef"))
    (range))
   n))

(defn pow [x n] (reduce * (repeat n x)))

(defn hex->dec [n]
  (->> n
      str
      seq
      (map b16->b10)
      reverse
      (map-indexed #(* (pow 16 %1) %2))
      (reduce +)))
#+END_SRC

*** least-valued elements of unsorted list

Idea from http://book.realworldhaskell.org/read/why-functional-programming-why-haskell.html

#+BEGIN_SRC clojure
;; find the k least-valued elements of an unsorted list

(def unsorted-list2 (map (fn [_] (rand-int 20)) (repeat 20 0)))

;; put first n numbers into sorted array
;; if curr < last, pop last and (sort (conj coll curr))

(defn find-least-valued-elements
  ([coll k] (find-least-valued-elements
             (drop k coll)
             (max k (count coll))
             (vec (sort (take k coll)))))
  ([coll k least-coll]
   (cond (empty? coll) least-coll
         (< (first coll) (last least-coll))
         (find-least-valued-elements (rest coll) k
                                     (vec (sort (conj (pop least-coll) (first coll)))))
         :else (find-least-valued-elements (rest coll) k least-coll))))

(find-least-valued-elements unsorted-list2 11)
#+END_SRC

*** Quil

[[https://github.com/quil/quil][github]]

[[http://www.tylerlhobbs.com/writings/using-quil-for-artwork][Using Quil for Artwork]], by Tyler Hobbs

*** slowdowns in emacs :noexport:

cider-font-lock-reader-conditionals

set cider-font-lock-dynamically to nil

https://github.com/clojure-emacs/cider/issues/2281

(setq cider-mode-line " cider")

*** style guides

- [[https://dev.clojure.org/display/community/Library+Coding+Standards][Clojure Community - Library Coding Standards]]
- [[https://github.com/bbatsov/clojure-style-guide][The Clojure Style Guide]], by [[https://twitter.com/bbatsov][Bozhidar Batsov]]

#+BEGIN_QUOTE
Use seq as a terminating condition to test whether a sequence is empty (this technique is sometimes called nil punning). [link]
#+END_QUOTE

#+BEGIN_SRC clojure
;; good
(defn print-seq [s]
  (when (seq s)
    (prn (first s))
    (recur (rest s))))

;; bad
(defn print-seq [s]
  (when-not (empty? s)
    (prn (first s))
    (recur (rest s))))
#+END_SRC

Other misc:

#+BEGIN_SRC clojure
;; good
(if-let [result (foo x)]
  (something-with result)
  (something-else))

;; good
(when-let [result (foo x)]
  (do-something-with result)
  (do-something-more-with result))

;; good
(if-not pred
  (foo))

;; good
(not= foo bar)

;; bad
(not (= foo bar))

;; good
(< 5 x 10)

;; bad
(and (> x 5) (< x 10))

;; good
(filter even? (range 1 10))

;; bad
(filter #(even? %) (range 1 10))

;; good
(filter (complement some-pred?) coll)

;; bad
(filter #(not (some-pred? %)) coll)

;; Assuming `(:require [clojure.string :as str])`...

;; good
(map #(str/capitalize (str/trim %)) ["top " " test "])

;; better
(map (comp str/capitalize str/trim) ["top " " test "])

;; good
(map #(+ 5 %) (range 1 10))

;; (arguably) better
(map (partial + 5) (range 1 10))

;; good
(-> [1 2 3]
    reverse
    (conj 4)
    prn)

;; not as good
(prn (conj (reverse [1 2 3])
           4))

;; good
(->> (range 1 10)
     (filter even?)
     (map (partial * 2)))

;; not as good
(map (partial * 2)
     (filter even? (range 1 10)))

;; good
(cond
  (= x 10) :ten
  (= x 20) :twenty
  (= x 30) :thirty
  :else :dunno)

;; much better
(condp = x
  10 :ten
  20 :twenty
  30 :thirty
  :dunno)

;; best
(case x
  10 :ten
  20 :twenty
  30 :forty
  :dunno)

;; good
(def ^:private a 5)

;; bad
(def ^{:private true} a 5)

;; good
(defn- private-fun [] ...)

(def ^:private private-var ...)

;; bad
(defn private-fun [] ...) ; not private at all

(defn ^:private private-fun [] ...) ; overly verbose

(def private-var ...) ; not private at all

;; good
(defn f->c ...)

;; not so good
(defn f-to-c ...)

;; good
(let [[a b _ c] [1 2 3 4]]
  (println a b c))

(dotimes [_ 3]
  (println "Hello!"))

;; bad
(let [[a b c d] [1 2 3 4]]
  (println a b d))

(dotimes [i 3]
  (println "Hello!"))

;; good
(defn frobnitz
  "This function does a frobnitz.
  It will do gnorwatz to achieve this, but only under certain
  circumstances."
  []
  ...)

;; bad
(defn frobnitz
  "This function does a frobnitz. It will do gnorwatz to
  achieve this, but only under certain circumstances."
  []
  ...)

;; good
(defn foo
  "docstring"
  [x]
  (bar x))

;; bad
(defn foo [x]
  "docstring"
  (bar x))
#+END_SRC

- Use ~lisp-case~ for function and variable names.
- Use ~CamelCase~ for protocols, records, structs, and types. (Keep acronyms like HTTP, RFC, XML uppercase.)

Follow clojure.core's example for idiomatic names like pred and coll.

functions:

| ~f~, ~g~, ~h~ | function input               |
| ~n~           | integer input usually a size |
| ~index~, ~i~  | integer index                |
| ~x~, ~y~      | numbers                      |
| ~xs~          | sequence                     |
| ~m~           | map                          |
| ~s~           | string input                 |
| ~re~          | regular expression           |
| ~coll~        | a collection                 |
| ~pred~        | a predicate closure          |
| ~& more~      | variadic input               |
| ~xf~          | xform, a transducer          |

macros:

| ~expr~    | an expression          |
| ~body~    | a macro body           |
| ~binding~ | a macro binding vector |

> Avoid writing comments to explain bad code. Refactor the code to make it self-explanatory.

| ~TODO~     |
| ~FIXME~    |
| ~OPTIMIZE~ |
| ~HACK~     |
| ~REVIEW~   |

*** transducers

[[http://clj-me.cgrand.net/2014/10/08/these-arent-the-reducing-functions-you-are-looking-for/][These aren’t the reducing functions you are looking for]], by [[https://github.com/cgrand][Christophe Grand]]

** recursion

Without tail call optimization (since it is not implicit):

#+BEGIN_SRC clojure
(defn no-tc-count [n]
  (if (zero? n)
    0
    (inc (no-tc-count (- n 1)))))
#+END_SRC

With tail call optimization using ~loop~ & ~recur~:

#+BEGIN_SRC clojure
(defn tc-count [n]
  (loop [x n, k 0]
    (if (zero? x)
      k
      (recur (dec x) (inc k)))))
#+END_SRC

** reference

- [[http://www.4clojure.com/][4Clojure]]
- [[https://clojure.org/api/cheatsheet][API Cheatsheet]]
- [[https://en.wikibooks.org/wiki/Learning_Clojure/Data_Structures][WikiBooks Learning Clojure Data Structure]]
- [[https://github.com/clojure-cookbook/clojure-cookbook][Clojure Cookbook github]]
- [[https://purelyfunctional.tv/guide/reagent/][Guide to Reagent]], by [[https://lispcast.com/about/][Eric Normand]]
- [[http://tonsky.me/blog/the-web-after-tomorrow/][The Web After Tomorrow]], by Nikita Prokopov/Tonsky
- [[https://data-sorcery.org/book-recommendations/][Incanter Book Recommendations]]
- https://clojurelibs.top/top

** repl :noexport:

#+begin_src clojure
(ns-publics 'myns.core)
(ns-aliases 'myns.core)
(clojure.repl/dir myns.core)
#+end_src

** test.check (spec/gen)

https://github.com/clojure/test.check/blob/master/doc/cheatsheet.md

https://github.com/clojure/test.check/blob/master/doc/intro.md

#+begin_src clojure

#+end_src

* Common Lisp
** books                                                           :noexport:
*** [[http://store.doverpublications.com/0486498204.html][Common Lisp]], by [[https://www.cs.cmu.edu/~dst/][David Touretsky]]
**** EVAL notation

Eval rules:
- symbols -> their variable's value
- T, NIL -> T, NIL
- numbers -> themselves
- lists (non special forms) -> func arg & args

**** chapter 8

ANYODDP

#+BEGIN_SRC lisp
(defun anyoddp (l)
  (cond ((null l) nil)
    ((equal (mod (first l) 2) 1) t)
    (t (anyoddp (rest l)))))

;; book
(defun anyoddp (x)
  (cond ((null x) nil)
        ((oddp (first x) t))
        (t (anyoddp (rest x)))))
#+END_SRC

*** [[https://www.apress.com/us/book/9781590592397][Practical Common Lisp]] by [[http://www.gigamonkeys.com/][Peter Siebel]]
**** Truth, Falsehood, and Equality

~NIL~ is both an atom and a list

> Using the empty list as false is a reflection o Lisp's heritage as a list-processing language much as the use of the integer 0 as false in C is a reflection of its heritage as a bit-twiddling language.

Scheme's ~#f~, ~nil~, and ~()~ are all distinct. CL's ~NIL~ and ~()~ are "completely interchangeable."

> And because ~NIL~... is the name of a constant variable with the symbol ~NIL~ as its value, the expressions ~nil~, ~()~, ~'nil~, and ~'()~ all evaluate to the same thing—the unquoted forms are evaluated as a reference to the constant variable whose value is the symbol ~NIL~, but in the quoted forms the ~QUOTE~ special operator evaluates to the symbol directly. For he same reason, both ~t~ and ~'t~ will evaluate to the same thing: the symbol ~T~.

| ~EQ~     | "object identity", do not use for numbers and characters          |
| ~EQL~    | ~EQ~ plus numbers & characters; PCL uses "'always use EQL' style" |
| ~EQUAL~  | loosens ~EQL~'s discrimination                                    |
| ~EQUALP~ | loosens more                                                      |

** reference

[[http://stevelosh.com/blog/2018/08/a-road-to-common-lisp/][A Road to Common Lisp]], by [[https://twitter.com/stevelosh][Steve Losh]]

[[http://www.lispworks.com/documentation/lw70/CLHS/Front/Contents.htm][Common Lisp HyperSpec]]

** special forms
*** setq

#+BEGIN_EXAMPLE
setq is a special form in ‘C source code’.

(setq [SYM VAL]...)

Set each SYM to the value of its VAL.
The symbols SYM are variables; they are literal (not evaluated).
The values VAL are expressions; they are evaluated.
Thus, (setq x (1+ y)) sets ‘x’ to the value of ‘(1+ y)’.
The second VAL is not computed until after the first SYM is set, and so on;
each VAL can use the new value of variables set earlier in the ‘setq’.
The return value of the ‘setq’ form is the value of the last VAL.

[back]
#+END_EXAMPLE

* Emacs Lisp

[[https://github.com/chrisdone/elisp-guide][Elisp Guide]], by [[https://github.com/chrisdone/][Chris Done]]

* Scheme
** books                                                           :noexport:
*** The Little Schemer

[[https://mitpress.mit.edu/books/little-schemer-fourth-edition][The Little Schemer]], by Daniel P. Friedman and Matthias Felleisen

#+BEGIN_SRC scheme
(define (atom? x)
  (and (not (pair? x)) (not (null? x))))
#+END_SRC

#+BEGIN_SRC scheme
(define (lat? l)
  (cond ((null? l) #t)
        ((atom? (car l)) (lat? (cdr l)))
        (else #f)))
#+END_SRC

#+BEGIN_SRC scheme
(define (member? a lat)
  (cond ((null? lat) #f)
        (else (or (eq? (cat lat) a))
              (member? a (cdr lat)))))
#+END_SRC

*** SICP
**** 1.3.1

compute sum of integers between ~a~ & ~b~:

#+BEGIN_SRC scheme
(define (int-sum a b)
  (cond ((> a b) 0)
        (else (+ a (int-sum (+ a 1) b)))))

(define (sum-integers a b)
  (if (> a b) 0
      (+ a (sum-integers (+ a 1) b))))
#+END_SRC

sum of the cubes of the integers in the given range:

#+BEGIN_SRC scheme
(define (cube x) (* x x x))
(define (cube-sum a b)
  (if (> a b)
      0
      (+ (cube a) (cube-sum (+ a 1) b))))

;; wrong... fix
(define (cube-sum2 a b)
  (let (cube (lambda (x) (* 3 3 3)))
   (if (> a b)
       0
       (+ (cube a) (cube-sum (+ a 1) b)))))
#+END_SRC

computes the sum of the series:

1/1*3 + 1/5*7 + 1/9*11

which converges to π/8 (very slowly)

#+BEGIN_SRC scheme
(define (pi-sum a b)
  (if (> a b)
      0
      (+ (/ 1.0 (* a (+ a 2)))
         (pi-sum (+ a 4) b))))
#+END_SRC

** misc

~(environment-bound? (nearest-repl/environment) 'is-this-defined)~

*** geometry

radian, degree, percentage conversion

#+BEGIN_SRC scheme
(defun r2d (rad)
  (* rad (/ 180 PI)))

(defun d2r (deg)
  (* deg (/ PI 180)))

(defun p2r (per)
  (d2r (* 360 per)))
#+END_SRC

*** remarks :noexport:

#+begin_quote
continuations remain an ugly stain on the otherwise clean manuscript of Scheme
#+end_quote

- Richard P. Gabriel, https://www.dreamsongs.com/WIB.html

** debugging

| ? | help, list command letters                                               |
| A | show All bindings in current environment and its ancestors               |
| B | move (Back) to next reduction (earlier in time)                          |
| C | show bindings of identifiers in the Current environment                  |
| D | move (Down) to the previous subproblem (later in time)                   |
| E | Enter a read-eval-print loop in the current environment                  |
| F | move (Forward) to previous reduction (later in time)                     |
| G | Go to a particular subproblem                                            |
| H | prints a summary (History) of all subproblems                            |
| I | redisplay the error message Info                                         |
| J | return TO the current subproblem with a value                            |
| K | continue the program using a standard restart option                     |
| L | (List expression) pretty print the current expression                    |
| M | (Frame elements) show the contents of the stack frame, in raw form       |
| O | pretty print the procedure that created the current environment          |
| P | move to environment that is Parent of current environment                |
| Q | Quit (exit debugger)                                                     |
| R | print the execution history (Reductions) of the current subproblem level |
| S | move to child of current environment (in current chain)                  |
| T | print the current subproblem or reduction                                |
| U | move (Up) to the next subproblem (earlier in time)                       |
| V | eValuate expression in current environment                               |
| W | enter environment inspector (Where) on the current environment           |
| X | create a read eval print loop in the debugger environment                |
| Y | display the current stack frame                                          |
| Z | return FROM the current subproblem with a value                          |

** reference

[[https://www.gnu.org/software/mit-scheme/documentation/mit-scheme-user/][MIT/GNY Scheme 9.4 documentation]]

[[http://www.neilvandyke.org/quack/quack.el][quack.el]]

[[https://groups.csail.mit.edu/mac/users/gjs/6.945/dont-panic/][Don't Panic!]] by rlm, larsj re debugging
