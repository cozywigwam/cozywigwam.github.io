#+OPTIONS: toc:nil -:nil H:6 ^:nil
#+EXCLUDE_TAGS: no_export
#+BEGIN_EXAMPLE
---
title: "Reactive"
layout: notation
description:
path: "/reactive/"
---
#+END_EXAMPLE

* rxjs

** interval

#+BEGIN_SRC js
this.confirmationInterval = Rx.Observable.interval(200)
  .takeUntil(() => activationHook === 'in' && !isPaused)
  .subscribe(() => {
    this.confirmationInterval.unsubscribe();
  });
#+END_SRC

** fetching

rxjs ajax method: http://reactivex.io/rxjs/class/es6/observable/dom/MiscJSDoc.js~AjaxRequestDoc.html#instance-method-createXHR

rxjs 5 ultimate example: https://chrisnoring.gitbooks.io/rxjs-5-ultimate/content/operators-and-ajax.html

from [[https://stackoverflow.com/questions/44877062/how-to-convert-a-fetch-api-response-to-rxjs-observable][SO]]: https://stackoverflow.com/questions/44877062/how-to-convert-a-fetch-api-response-to-rxjs-observable

#+BEGIN_SRC js
var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));
result.subscribe(x => console.log(x), e => console.error(e));
#+END_SRC

#+BEGIN_SRC js
const getData = (url, params) => {
    return fetch(url, params).then(r => {
        return r.ok ? r.text() : Promise.reject(`${r.statusText} ${r.status}`)
    })
}

const getDataObserver = (url, params) => Rx.Observable.fromPromise(getData())
#+END_SRC

bacon style:

#+BEGIN_SRC js
function toResultStream(request) {
  return Bacon.fromPromise($.ajax(request))
}
availabilityResponse = availabilityRequest.flatMap(toResultStream)
#+END_SRC

staltz:

#+BEGIN_SRC js
var requestStream = Rx.Observable.just('https://api.github.com/users');

var responseStream = requestStream
  .flatMap(function(requestUrl) {
    return Rx.Observable.fromPromise(jQuery.getJSON(requestUrl));
  });

responseStream.subscribe(function(response) {
  // render `response` to the DOM however you wish
});
#+END_SRC

** assorted links/docs

3 common errors by Chris Pawlukiewicz on medium: https://medium.com/@paynoattn/3-common-mistakes-i-see-people-use-in-rx-and-the-observable-pattern-ba55fee3d031

baconjs tutorial: https://baconjs.github.io/tutorials.html

fromEvent: http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-fromEvent

using fetch API:
https://chrisnoring.gitbooks.io/rxjs-5-ultimate/content/operators-and-ajax.html

Rxjs 5 ultimate git book: https://chrisnoring.gitbooks.io/rxjs-5-ultimate/content/

James Flight hackernoon blog post: https://hackernoon.com/using-rxjs-to-handle-http-requests-what-ive-learned-4640aaf4646c

** Andre Staltz post: https://gist.github.com/staltz/868e7e9bc2a7b8c1f754

"A Promise is simply an Observable with one single emitted value."

** Ben Lesh blog post

https://medium.com/@benlesh/rxjs-dont-unsubscribe-6753ed4fda87

#+BEGIN_SRC js
 updateData(data) {
  // do something framework-specific to update your component here.
 }

 onMount() {
   const data$ = this.getData();
   const cancelBtn = this.element.querySelector(‘.cancel-button’);
   const rangeSelector = this.element.querySelector(‘.rangeSelector’);
   const cancel$ = Observable.fromEvent(cancelBtn, 'click');
   const range$ = Observable.fromEvent(rangeSelector, 'change').map(e => e.target.value);

   const stop$ = Observable.merge(cancel$, range$.filter(x => x > 500))
   this.subscription = data$.takeUntil(stop$).subscribe(data => this.updateData(data));
 }

 onUnmount() {
  this.subscription.unsubscribe();
}
#+END_SRC

- compose a stream of ~stop$~ events that kill the data stream... that way, if you want to add another "stop" condition (like a timer), you can "simply merge a new observable into `stop$`"
- this "completes the observable" - there's a completion event that can be handled anytime you want to kill your observable. If you just call "unsubscribe" on `this.subscription`, you won't be notified... however `takeUntil` will notify you via the completion handler
- "There is one disadvantage here in terms of RxJS semantics, but it’s barely worth worrying about in the face of the other advantages. The semantic disadvantage is that completing an observable is a sign that the producer wants to tell the consumer it’s done, where unsubscribing is the consumer telling the producer it no longer cares about the data."

Other operators

There are many other ways to kill a stream in a more “Rx-y” way. I’d recommend checking out the following operators at the very least:

- take(n): emits N values before stopping the observable.
- takeWhile(predicate): tests the emitted values against a predicate, if it returns `false`, it will complete.
- first(): emits the first value and completes.
- first(predicate): checks each value against a predicate function, if it returns `true`, the emits that value and completes.

Summary: Use takeUntil, takeWhile, et al.

You should probably be using operators like `takeUntil` to manage your RxJS subscriptions. As a rule of thumb, if you see two or more subscriptions being managed in a single component, you should wonder if you could be composing those better.

- more composeable
- fires a completion event when you kill your stream
- generally less code
- less to manage
- fewer actual points of subscription (because fewer calls to `subscribe`)

* Misc


Suffixing observable names with `$` comes from cycle.js: https://cycle.js.org/basic-examples.html#basic-examples-increment-a-counter-what-is-the-convention

** split strings at \n

[[https://stackoverflow.com/questions/38991362/what-is-the-reactive-way-to-read-file-line-by-line][SO ref]]

#+BEGIN_SRC js
    Rx.Observable.of('first\nstring')
      .concat(Rx.Observable.of('asdf\nzxcvzc\nsd fawef\nsdfs\n')) // parens was missing // to make sure we don't miss the last line!
      .scan(
        ({ buffer }, b) => {
          const splitted = buffer.concat(b).split('\n');
          const rest = splitted.pop();
          return { buffer: rest, items: splitted };
        },
        { buffer: '', items: [] }
      )
      // Each item here is a pair { buffer: string, items: string[] }
      // such that buffer contains the remaining input text that has no newline
      // and items contains the lines that have been produced by the last buffer
      .concatMap(({ items }) => items)
      // we flatten this into a sequence of items (strings)
      .subscribe(
        item => console.log(item),
        err => console.log(err),
        () => console.log('Done with this buffer source')
      );
#+END_SRC

** disposing/cleaning up

[[https://github.com/Reactive-Extensions/RxJS/issues/1016][github issue]]

When you unsubscribe() (aka dispose) of a subscription it will be chained back up to all of the subscriptions that it is composed of.
