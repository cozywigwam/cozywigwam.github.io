#+OPTIONS: toc:nil -:nil H:6 ^:nil
#+EXCLUDE_TAGS: noexport
#+BEGIN_EXAMPLE
---
title: "ML"
layout: notation
description: So There's This Type of Programming...
path: "/ml/"
---
#+END_EXAMPLE

* Books

** The Little MLer

[[https://mitpress.mit.edu/books/little-mler][The Little MLer,]] Matthias Felleisen and Daniel P. Friedman

#+BEGIN_SRC sml
datatype shish_kebab =
         Skewer
         | Onion of shish_kebab
         | Lamb of shish_kebab
         | Tomato of shish_kebab;

fun is_vegetarian (Skewer)
    = true
  | is_vegetarian (Onion(x))
    = is_vegetarian (x)
  | is_vegetarian (Lamb(x))
    = false
  | is_vegetarian (Tomato(x))
    = is_vegetarian (x);

is_vegetarian: shish_kebab -> bool;
#+END_SRC

#+BEGIN_SRC sml
datatype 'a shish =
         Bottom of 'a
         | Onion of 'a shish
         | Lamb of 'a shish
         | Tomato of 'a shish;

fun is_veggie (Bottom(x)) = true
  | is_veggie (Onion(x)) = is_veggie (x)
  | is_veggie (Lamb(x)) = false
  | is_veggie (Tomato(x)) = is_veggie (x);

is_veggie: 'a shish -> bool;
#+END_SRC

*** 3 cons is still magnificent

moral - Functions that produce values of a datatype must use the associated constructors to build data of that type.

#+BEGIN_SRC sml
datatype pizza =
         Crust
         | Cheese of pizza
         | Onion of pizza
         | Anchovy of pizza
         | Sausage of pizza;

fun remove_anchovy (Crust) =
    Crust
  | remove_anchovy (Cheese(x)) =
    Cheese(remove_anchovy(x))
  | remove_anchovy (Onion(x)) =
    Onion(remove_anchovy(x))
  | remove_anchovy (Anchovy(x)) =
    remove_anchovy(x)
  | remove_anchovy (Sausage(x)) =
    Sausage(remove_anchovy(x));

remove_anchovy: pizza -> pizza;



fun top_anchovy_with_cheese (Crust) =
    Crust
  | top_anchovy_with_cheese (Cheese(x)) =
    Cheese(top_anchovy_with_cheese(x))
  | top_anchovy_with_cheese (Onion(x)) =
    Onion(top_anchovy_with_cheese(x))
  | top_anchovy_with_cheese (Anchovy(x)) =
    Cheese(Anchovy(top_anchovy_with_cheese(x)))
  | top_anchovy_with_cheese (Sausage(x)) =
    Sausage(top_anchovy_with_cheese(x));

top_anchovy_with_cheese: pizza -> pizza;

(* top_anchovy_with_cheese(Onion(Anchovy(Cheese(Anchovy(Crust))))); *)
(* -> (Onion(Cheese(Anchovy(Cheese(Cheese(Anchovy(Crust))))))) *)
#+END_SRC

*** morals

1 - Use datatype to describe types. When a type contains lots of values, the datatype definition refers to itself. Use Î± with datatype to define shapes.
2 - The number and order of the patterns in the definition of a function should match that of the definition of the consumed datatype.
3 - Functions that produce values of a datatype must use the associated constructors to build data of that type.

** ML for the Working Programmer

[[https://www.cambridge.org/core/books/ml-for-the-working-programmer/BDAAF5C30634CC39385F75C97274BFCC][ML for the Working Programmer]], L.C. Paulson

*** gcd/Euclid's algorithm

#+begin_src sml
fun gcd(m, n) =
    if m=0 then n
    else gcd(n mod m, m);
#+end_src

*** count elements in a list

#+begin_src sml
fun length [] = 0
  | length [x :: xs] = 1 + length xs;
#+end_src

*** valid day/month

#+begin_src sml
(* 25 "October" *)
fun twenty_nine_month (d : int) =
    d > 0 andalso d <= 29;

fun thirty_month (d : int) =
    d > 0 andalso d <= 30;

fun thirty_one_month (d : int) =
    d > 0 andalso d <= 31;

(* e.g. 25 "October" *)
fun is_valid_date (d : int, m : string) : bool =
    thirty_one_month(d) andalso m = "January"
    orelse twenty_nine_month(d) andalso m = "February"
    orelse thirty_one_month(d) andalso m = "March"
    orelse thirty_month(d) andalso m = "April"
    orelse thirty_one_month(d) andalso m = "May"
    orelse thirty_month(d) andalso m = "June"
    orelse thirty_one_month(d) andalso m = "July"
    orelse thirty_month(d) andalso m = "August"
    orelse thirty_one_month(d) andalso m = "September"
    orelse thirty_month(d) andalso m = "October"
    orelse thirty_one_month(d) andalso m = "November"
    orelse thirty_month(d) andalso m = "December";
#+end_src

*** misc

> Function application binds more tightly than infix operators. For instance, ~area a + b~ is equivalent to ~(area a) + b~, not ~area (a + b)~.

Unary minus, =~=, is different from subtraction, =-=.

Specify arg:

#+begin_src sml
val sq_arg (x : real) = x*x;
#+end_src

Specify result:

#+begin_src sml
val sq_arg x : real = x*x;
#+end_src

Specify body:

#+begin_src sml
val sq_arg x = x*x : real;
#+end_src



* misc

** indentation/formatting

from [[https://www.smlnj.org/doc/Emacs/sml-mode.html#dir][SML mode - The Emacs SML editing mode]]

#+BEGIN_QUOTE
2 Editing with SML Mode

Now SML mode provides just a few additional editing commands. Most of the work has gone into implementing the indentation algorithm which, if you think about it, has to be complicated for a language like ML. See Indentation Defaults, for details on how to control some of the behaviour of the indentation algorithm. Principal goodies are the `electric pipe' feature, and the ability to insert common SML forms (macros or templates).
#+END_QUOTE

#+BEGIN_QUOTE
2.2 Automatic indentation

ML is a complicated language to parse, let alone compile. The indentation algorithm is a little wooden (for some tastes), and the best advice is not to fight it! There are several variables that can be adjusted to control the indentation algorithm (see Customising SML Mode, below).
#+END_QUOTE

* reference

[[http://sml-family.org/Basis/manpages.html][The Standard ML Basis Library]]
