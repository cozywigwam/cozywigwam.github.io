#+OPTIONS: toc:nil -:nil H:6 ^:nil
#+EXCLUDE_TAGS: noexport
#+BEGIN_EXAMPLE
---
title: "JavaScript"
layout: notation
description:
path: "/javascript/"
---
#+END_EXAMPLE

* Language
** Arrays :noexport:

*** Copying

[[https://stackoverflow.com/questions/7486085/copying-array-by-value-in-javascript/23536726#23536726][Good SO answer]]

If it's an array of primitives, use ~slice()~ (or ~concat()~):

#+BEGIN_SRC js
var myArray = [3, "str", true];

var dupe = myArray.slice();
// or
var dupe2 = myArray.concat();
dupe[0] = 4;
console.log('myArray', myArray);
#+END_SRC

If it's an array of objects, this will result in a shallow copy:

#+BEGIN_SRC js
var myObjArray = [
  {
    name: 'Miles',
    instrument: 'trumpet'
  },
  {
    name: 'John',
    instrument: 'saxophone'
  }
]

var shallowDupe = myObjArray.slice();
shallowDupe[0].name = 'Clifford';

console.log('myObjArray', myObjArray); // Clifford overwrote Miles
#+END_SRC

Instead, one alternative is to stringify and parse:

#+BEGIN_SRC js
var myObjArray = [
  {
    name: 'Miles',
    instrument: 'trumpet'
  },
  {
    name: 'John',
    instrument: 'saxophone'
  }
]

var dupe = myObjArray.slice();
// dupe[0].name = 'Clifford'; // would overwrite myObjArray

var dupe2 = JSON.parse(JSON.stringify(myObjArray));
dupe2[0].name = 'Dexter'; // myObjArray and dupe2 are different
#+END_SRC

** Async

[[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/async_function][MDN]]

#+BEGIN_SRC js
async function [name]([param1[, param2[, ..., paramN]]]) {
   statements
}
#+END_SRC

Hacker Noon post [[https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9][6 Reasons Why JavaScriptâ€™s Async/Await Blows Promises Away]] from [[https://twitter.com/imGaafar][Mostafa Gaafar]]:

** Callbags

https://github.com/staltz/callbag-basics

https://www.youtube.com/watch?v=HssczgaY9BM

"What I called the 'callbag pattern.'"

"The idea is that the producer and consumer are symmetric: they have the same signature."

#+BEGIN_SRC js
function producer(type, payload) {
  if (type === 'start') {
    // on start, you know the payload is a callback
    const consumer = payload;
    let i = 0;
    let handle;

    // I can listen to the consumer with another function:
    // it's a nested callback
    consumer('start', (type, payload) => {
      if (type === 'data') i = payload;
      if (type === 'stop') clearInterval(incInt);
    });

    incInt = setInterval(() => {
      consumer('data', i);
      i++;
    }, 1000);
  }
}

function consumer(type, payload) {
  // subscribe
  if (type === 'start') {
    // you know payload is a callback
    const cb = payload;

    setTimeout(() => {
      console.log('hello')
      cb('data', 17)
    }, 1200);

    setTimeout(() => {
      // this calls the "nested callback" filtered by type === 'stop'
      // (t,p)=>{if (t==='stop') clearInterval(handle)}
      cb('stop');
    }, 3500);
  }
  if (type === 'data') {
    console.log(payload);
  }
}

producer('start', consumer);
#+END_SRC

** Currying :noexport:

Function takes two:

#+BEGIN_SRC js
const myCurryTwo = function(func) {
  return function(value) {
    func(value);
  }
}

const myCurryTwo2 = f => x => f(x)
#+END_SRC

** Destructuring

*** Arrays

*** Objects

#+BEGIN_SRC js :cmd "org-babel-node"
  let structured = {
    title: 'structured title',
    description: 'structured desc'
  }

  const { title, description } = structured;

  console.log(title);
  console.log(description);
#+END_SRC

#+RESULTS:
: structured title
: structured desc
: undefined


#+BEGIN_SRC js :cmd "org-babel-node --presets=stage-2"
let obj1 = {
  bird: "falcon2",
  frog: "bullfrog"
}
let { bird, frog: frogName } = obj1;
console.log(bird);
console.log(frogName);

let obj2 = {
  fruit: "apple",
  veggie: "kale",
  meat: "tofuball"
}
let { fruit, ...restItem } = obj2;
console.log(fruit);
console.log(restItem);
#+END_SRC

** Format
*** Prettier

[[https://prettier.io/docs/en/options.html][Prettier Options]]

With [[https://github.com/typicode/husky][husky]] and [[https://github.com/okonet/lint-staged][lint-staged]]:

#+BEGIN_SRC js
/* package.json */

// ...

"scripts": {
  "precommit": "lint-staged",

// ...

"lint-staged": {
  "src/**/*.{js,jsx,json,css,scss}": [
    "prettier --single-quote --jsx-bracket-same-line --trailing-comma es5 --write",
    "git add"
  ]
},

// ...

#+END_SRC

*** run it through files

#+BEGIN_SRC sh
prettier --single-quote --jsx-bracket-same-line --trailing-comma es5 --write "src/**/*.{js,jsx,json,css,scss}"
prettier --single-quote --jsx-bracket-same-line --trailing-comma es5 --write "**/*.js"
#+END_SRC

*** reference

[[https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#formatting-code-automatically][CRA docs]]

** Iterators

From [[https://nostarch.com/ecmascript6][Understanding ECMASCRIPT 6]] by [[https://twitter.com/slicknet][Nicholas Zakas]]

ES5 iterator:

#+BEGIN_SRC js
const createIterator = items => {
  let i = 0;

  return {
    next: () => {
      const done = i <= items.length;
      const value = !done && items[i++];

      return {
        value: value,
        done: done,
      };
    },
  };
};
#+END_SRC

ES6 equivalent:

#+BEGIN_SRC js
const createIterator
#+END_SRC

** Promises

*** [[https://github.com/nolanlawson][Nolan Lawson]]

**** [[https://gist.github.com/nolanlawson/6ce81186421d2fa109a4][Promise protips - stuff I wish I had known when I started with Promises]]

#+BEGIN_QUOTE
Promise.all is good for executing many promises at once

#+BEGIN_SRC js
Promise.all([
  promise1,
  promise2
]);
#+END_SRC

Promise.resolve is good for wrapping synchronous code

#+BEGIN_SRC js
Promise.resolve().then(function () {
  if (somethingIsNotRight()) {
    throw new Error("I will be rejected asynchronously!");
  } else {
    return "This string will be resolved asynchronously!";
  }
});
#+END_SRC

execute some promises one after the other.
this takes an array of promise factories, i.e.
an array of functions that RETURN a promise
(not an array of promises themselves; those would execute immediately)

#+BEGIN_SRC js
function sequentialize(promiseFactories) {
  var chain = Promise.resolve();
  promiseFactories.forEach(function (promiseFactory) {
    chain = chain.then(promiseFactory);
  });
  return chain;
}
#+END_SRC

Promise.race is good for setting a timeout:

#+BEGIN_SRC js
Promise.race([
  new Promise(function (resolve, reject) {
    setTimeout(reject, 10000); // timeout after 10 secs
  }),
  doSomethingThatMayTakeAwhile()
]);
#+END_SRC

Promise finally util similar to Q.finally
e.g. promise.then(...).catch().then(...).finally(...)

#+BEGIN_SRC js
function finally (promise, cb) {
  return promise.then(function (res) {
    var promise2 = cb();
    if (typeof promise2.then === 'function') {
      return promise2.then(function () {
        return res;
      });
    }
    return res;
  }, function (reason) {
    var promise2 = cb();
    if (typeof promise2.then === 'function') {
      return promise2.then(function () {
        throw reason;
      });
    }
    throw reason;
  });
};
#+END_SRC
#+END_QUOTE

*** [[https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html][Nolan Lawson's Blog Post]]

Abbreviated:

#+BEGIN_QUOTE
Q: What is the difference between these four promises?

#+BEGIN_SRC js
doSomething().then(function () {
  return doSomethingElse();
});

doSomething().then(function () {
  doSomethingElse();
});

doSomething().then(doSomethingElse());

doSomething().then(doSomethingElse);
#+END_SRC

Mistakes outlined:

- "promisey pyramid of doom"
- ~forEach()~ instead of ~map()~
- missing ~catch()~
- using "deferred"
- side effects instead of returning
#+END_QUOTE

**** Your Three Options When Inside ~then()~

- return another promise
- return a synchronous value (or undefined)
- throw a synchronous error

#+BEGIN_QUOTE
Every promise gives you a ~then()~ method (or ~catch()~, which is just sugar for ~then(null, ...))~. Here we are inside of a ~then()~ function:

#+BEGIN_SRC js
somePromise().then(function () {
  // I'm inside a then() function!
});
#+END_SRC

There are three things:

- return another promise

#+BEGIN_SRC js
getUserByName('nolan').then(function (user) {
  return getUserAccountById(user.id);
}).then(function (userAccount) {
  // I got a user account!
});
#+END_SRC

- return a synchronous value (or undefined)

#+BEGIN_SRC js
getUserByName('nolan').then(function (user) {
  if (inMemoryCache[user.id]) {
    return inMemoryCache[user.id];    // returning a synchronous value!
  }
  return getUserAccountById(user.id); // returning a promise!
}).then(function (userAccount) {
  // I got a user account!
});
#+END_SRC

- throw a synchronous error

#+BEGIN_SRC js
getUserByName('nolan').then(function (user) {
  if (user.isLoggedOut()) {
    throw new Error('user logged out!'); // throwing a synchronous error!
  }
  if (inMemoryCache[user.id]) {
    return inMemoryCache[user.id];       // returning a synchronous value!
  }
  return getUserAccountById(user.id);    // returning a promise!
}).then(function (userAccount) {
  // I got a user account!
}).catch(function (err) {
  // Boo, I got an error!
});
#+END_SRC
#+END_QUOTE

**** Advanced Mistakes

- Not knowing about Promise.resolve()
- ~then(resolveHandler).catch(rejectHandler)~ isn't exactly the same as ~then(resolveHandler, rejectHandler)~
- Promises vs. Promise Factories
- Higher-scoped variable for combined promise results
- Promises fall through

#+BEGIN_QUOTE
- Not knowing ~Promise.resolve()~

#+BEGIN_SRC js
function somePromiseAPI() {
  return Promise.resolve().then(function () {
    doSomethingThatMayThrow();
    return 'foo';
  }).then(/* ... */);
}
#+END_SRC

Just remember: any code that might ~throw~ synchronously is a good candidate for a nearly-impossible-to-debug swallowed error somewhere down the line. But if you wrap everything in ~Promise.resolve()~, then you can always be sure to ~catch()~ it later.

- ~then(resolveHandler).catch(rejectHandler)~ isn't exactly the same as ~then(resolveHandler, rejectHandler)~

#+BEGIN_SRC js
somePromise().then(function () {
  throw new Error('oh noes');
}).catch(function (err) {
  // I caught your error! :)
});

somePromise().then(function () {
  throw new Error('oh noes');
}, function (err) {
  // I didn't catch your error! :(
});
#+END_SRC

As it turns out, when you use the ~then(resolveHandler, rejectHandler)~ format, the ~rejectHandler~ won't actually catch an error if it's thrown by the ~resolveHandler~ itself.

- Promises vs. Promise Factories

#+BEGIN_SRC js
// good, will execute sequentially as expected

function executeSequentially(promiseFactories) {
  var result = Promise.resolve();
  promiseFactories.forEach(function (promiseFactory) {
    result = result.then(promiseFactory);
  });
  return result;
}

// ...

function myPromiseFactory() {
  return somethingThatCreatesAPromise();
}
#+END_SRC

- Higher-scoped variable for combined promise results

#+BEGIN_SRC js
// no
var user;
getUserByName('nolan').then(function (result) {
  user = result;
  return getUserAccountById(user.id);
}).then(function (userAccount) {
  // okay, I have both the "user" and the "userAccount"
});

// yes
getUserByName('nolan').then(function (user) {
  return getUserAccountById(user.id).then(function (userAccount) {
    // okay, I have both the "user" and the "userAccount"
  });
});
#+END_SRC

- Promises fall through

#+BEGIN_SRC js
Promise.resolve('foo').then(null).then(function (result) {
  console.log(result);
});
#+END_SRC
#+END_QUOTE

*** Other References

[[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise][MDN]]

** Reduce

[[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce][MDN Array.prototype.reduce()]]

#+BEGIN_SRC js
const myArr = [1, 2, 3]
const myAdditionReducer = (acc, n) => acc + n;
myArr.reduce(myAdditionReducer); // 6
#+END_SRC

* Libraries
** D3
*** nvd3

[[http://nvd3-community.github.io/nvd3/examples/documentation.html][Documentation]]

create nv chart (from [[https://css-tricks.com/how-to-make-a-modern-dashboard-with-nvd3-js/][How to Make a Modern Dashboard with nvd3.js]])

#+BEGIN_SRC js
nv.addGraph(function () {
  var chart = nv.models.lineChart() // Initialise the lineChart object.
    .useInteractiveGuideline(true); // Turn on interactive guideline (tooltips)
chart.xAxis
    .axisLabel('TimeStamp (Year)'); // Set the label of the xAxis (Vertical)
chart.yAxis
    .axisLabel('Degrees (c)') // Set the label of the xAxis (Horizontal)
    .tickFormat(d3.format('.02f')); // Rounded Numbers Format.
d3.select('#averageDegreesLineChart svg') // Select the ID of the html element we defined earlier.
    .datum(temperatureIndexJSON) // Pass in the JSON
    .transition().duration(500) // Set transition speed
    .call(chart); // Call & Render the chart
  nv.utils.windowResize(chart.update); // Intitiate listener for window resize so the chart responds and changes width.
  return;
});
#+END_SRC

** Ramda :noexport:
*** hard to understand
**** setting initial redux states

#+BEGIN_SRC js
import navFooterGlobalReducer from 'reducers/navFooterGlobal';

const initialNavFooterGlobalState = {
  navFooterGlobal: [],
};

const loadReducer = R.curry((initialState, reducer, state, action) => {
  try {
    return R.invoker(2, action.type)(
      R.defaultTo(initialState, state),
      action,
      reducer
    );
  } catch (e) {
    return R.defaultTo(initialState, state);
  }
});

export default combineReducers({
  navFooterGlobal: loadReducer(
    initialNavFooterGlobalState,
    navFooterGlobalReducer
  ),
});

import reducers from './reducers';

const store = compose(
  applyMiddleware(routerMiddleware(history), thunk),
  window.__REDUX_DEVTOOLS_EXTENSION__
    ? window.__REDUX_DEVTOOLS_EXTENSION__()
    : f => f
)(createStore)(reducers);
#+END_SRC

Rather than setting initial state when combining the reducers, the redux docs show setting initial state [[https://redux.js.org/basics/reducers#handling-actions][this way]]:

#+BEGIN_SRC js
import { VisibilityFilters } from './actions'

const initialState = {
  visibilityFilter: VisibilityFilters.SHOW_ALL,
  todos: []
}

function todoApp(state = initialState, action) {
  switch (action.type) {
    case SET_VISIBILITY_FILTER:
      return Object.assign({}, state, {
        visibilityFilter: action.filter
      })
    default:
      return state
  }
}
#+END_SRC

Seems like "loadReducer" should be named "fallbackNilToInitialStateAndCatchUndefined." It's doing three things:

1 - curryingl

Secondly, I feel like "loadReducer" is misnamed. Seems like it's not "loading" a reducer, but rather applying ~R.invoker~ (in a possibly un-idiomatic way?) to use an initial state in case of null.

Re ~invoker~, it's saying "I want to call ~action.type~ with two arguments," and then immediately invoking the returned function with an arity mismatch error of 3 arguments: 1 - (R.defaultTo(initialState, state), action, reducer). First of all, it's a bit convoluted or magical here because loadReducer's try block doesn't evaluate until it's received the curried in final 2 arguments from combineReducer. This is "magical" because it currently looks like combineReducers has a set of key/value pairs where the value is a binary function... but it's not binary, because combineReudcers is passing the final two curried args in.

Re ~R.defaultTo(initialState, state)~, I'm unclear on why the ~state~ would be null. What sort of reducer would be giving a null state here?

I'm also unclear on why there's a try/catch. What type of error do we anticipate here? I would initially think "arity," but it's curried, so my gut tells me that a try/catch here might lead to more subtle bugs rather than assist in catching others..?

And why is it curried? It's only called in one very specific place in the code, to do one very specific thing (swap a null action for a fallback/default initial state), and that calls it with two arguments.

ref https://github.com/reduxjs/redux/blob/master/docs/api/combineReducers.md ...

> While combineReducers attempts to check that your reducers conform to some of these rules, you should remember them, and do your best to follow them. combineReducers will check your reducers by passing undefined to them; this is done even if you specify initial state to Redux.createStore(combineReducers(...), initialState). Therefore, you must ensure your reducers work properly when receiving undefined as state, even if you never intend for them to actually receive undefined in your own code.

... this might be the ratioanle behind the try/catch... but it seems like the rationale behind the initialStates and defatulTo as well... I suppose they're doing different things.


**** unorthodox, misnamed, convoluted, uncommented data transformation

#+BEGIN_SRC js
const idKeyAsProp = (a, b) => R.assoc(b.id, b, a);

const SavedDashboardsReducer = (state = initialState, action) => {
  switch (action.type) {
  case `${FETCH_ALL}_SUCCESS`: {
    return R.compose(
      R.assoc('data', R.__, state),
      R.reduce(idKeyAsProp, {}),
      R.pathOr([], ['payload', 'data', 'data'])
    )(action);
  }
};
#+END_SRC

This reads like a puzzle. Reducing an ~assoc~ with ~(a, b) -> (b.id, b, a)~? Difficulties:

1) ~assoc~'s signature is ~String â†’ a â†’ {k: v} â†’ {k: v}~, which is surprising, particularly without extended Ramda knowledge

2) transforming an object that contains a key property into a key/value pair with said id as the key is an unorthodox data manipulation: a) why? b) doesn't this duplicate the nested 'id' property now?

3) naming error: "idKeyAsProp" should read "idPropAsKey"

#+BEGIN_SRC js
before = { id: 1, value: 'cat' }
after = { 1: { id: 1, value: 'cat' } }
#+END_SRC

The reduction is using this transformation as the iterator function to construct a new object.

#+BEGIN_SRC js
fetchResponse = [
  { id: 1, value: 'cat' },
  { id: 2, value: 'dog' }
]
reductionResult = {
  1: { id: 1, value: 'cat' },
  2: { id: 2, value: 'dog' }
}
#+END_SRC

Then ~R.assoc('data', R.__, state)~ appends the full existing ~state~ object with a key of ~'data'~:

#+BEGIN_SRC js
result = {
  1: { id: 1, value: 'cat' },
  2: { id: 2, value: 'dog' }
  'data': { <state object, whatever it might be> }
}
#+END_SRC

** React
*** Redux

**** [[https://github.com/reduxjs/react-redux/blob/master/docs/api.md#connect][connect]]

#+BEGIN_SRC js
connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])

// mapStateToProps(state, [ownProps]): stateProps
// mapDispatchToProps(dispatch, [ownProps]): dispatchProps

// mergeProps(stateProps, dispatchProps, ownProps): props
//   - default is Object.assign({}, ownProps, stateProps, dispatchProps)
#+END_SRC

- ~mapStateToProps~ - subscribe to store
- ~mapDispatchToProps~ - accepts object or function, use to bind action creators
- ~mergeProps~ - select a slice of state, bind action creators to a variable

Inject todos of a specific user depending on props, and inject props.userId into the action ([[https://github.com/reduxjs/react-redux/blob/master/docs/api.md#inject-todos-of-a-specific-user-depending-on-props-and-inject-propsuserid-into-the-action][ref]]):

#+BEGIN_SRC js
import * as actionCreators from './actionCreators'

function mapStateToProps(state) {
  return { todos: state.todos }
}

function mergeProps(stateProps, dispatchProps, ownProps) {
  return Object.assign({}, ownProps, {
    todos: stateProps.todos[ownProps.userId],
    addTodo: (text) => dispatchProps.addTodo(ownProps.userId, text)
  })
}

export default connect(mapStateToProps, actionCreators, mergeProps)(TodoApp)
#+END_SRC


***** mapStateToProps

#+BEGIN_SRC js
function mapStateToProps(state) {
  return { todos: state.todos }
}

const mapStateToProps = state => {
  return { user: state.user };
};

const mapStateToProps = state => ({
  user: state.user
});

const mapStateToProps = state => ({
  user
});

// spread
const mapStateToProps = (state, ownProps) => ({
  ...state.user,
});

// destructure
const mapStateToProps = ({ user: { name, email } }) => {
  return { name, email };
};

const mapStateToProps = ({ user: { name, email } }) => ({
  name,
  email,
});
#+END_SRC

***** mapDispatchToProps

no mapping:

#+BEGIN_SRC js
// usage
this.props.dispatch(updateUser(username, email));
#+END_SRC

with mapping, as object:

#+BEGIN_SRC js
// setup
const mapDispatchToProps = {
  updateUser,
};

// connect with mdtp
export default connect(mapStateToProps, mapDispatchToProps)(Login);

// usage
updateUser(username, email);
#+END_SRC

***** mergeProps

#+BEGIN_SRC js
function mergeProps(stateProps, dispatchProps, ownProps) {
  return Object.assign({}, ownProps, {
    todos: stateProps.todos[ownProps.userId],
    addTodo: (text) => dispatchProps.addTodo(ownProps.userId, text)
  })
}
#+END_SRC

*** reselect

**** withProps, setPropTypes

#+BEGIN_SRC js
export default compose(
  withProps(
    ({
      widgetData: {
        metaJson: { widgetType },
      },
    }) => ({ widgetType})
  ),
  setPropTypes({
    widgetData: PropTypes.object.isRequired,
    widgetType: PropTypes.string,
  })
)(Widget);
#+END_SRC

#+BEGIN_SRC js
export default compose(
  withProps(({ widgetData: { description, filteredWidgetData, title } }) => ({
    description,
    title,
    feedbackWidgetContents: R.compose(
      R.filter(({ feedback }) => Boolean(feedback)),
      R.map(
        R.compose(
          R.zipObj(['checkInTime', 'projectName', 'feedback']),
          RA.paths([
            ['expectedCheckinTime'],
            ['metaJson', 'projectName'],
            ['formState', 'feedback', 'message'],
          ])
        )
      )
    )(filteredWidgetData),
  })),
  setPropTypes({
    description: PropTypes.string,
    feedbackWidgetContents: PropTypes.arrayOf(
      PropTypes.shape({
        checkInTime: PropTypes.string,
        feedback: PropTypes.string,
        projectName: PropTypes.string,
      })
    ),
    title: PropTypes.string,
    widgetData: PropTypes.object.isRequired,
  })
)(FeedbackWidgetContainer);
#+END_SRC

**** withProps, withStateHandlers, setPropTypes

#+BEGIN_SRC
export default compose(
  withProps(() => {
    return {
      title: mockData.title,
      description: mockData.description,
      photoWidgetContents: mockData.filteredWidgetData,
    };
  }),
  withStateHandlers(
    ({ currentSlide = 0, isDetailView = false }, open = false) => ({
      currentSlide,
      isDetailView,
      open,
    }),
    {
      handlePreviousSlide: (
        { currentSlide },
        { photoWidgetContents }
      ) => () => ({
        currentSlide:
          currentSlide - 1 < 0
            ? photoWidgetContents.length - 1
            : currentSlide - 1,
      }),
      handleNextSlide: ({ currentSlide }, { photoWidgetContents }) => () => ({
        currentSlide:
          currentSlide + 1 > photoWidgetContents.length - 1
            ? 0
            : currentSlide + 1,
      }),
      toggleDetailView: ({ isDetailView }) => () => ({
        isDetailView: !isDetailView,
      }),
    }
  ),
  setPropTypes({
    description: PropTypes.string,
    title: PropTypes.string,
    widgetData: PropTypes.object.isRequired,
  })
)(PhotoWidgetContainer);
#+END_SRC

** Components

*** Syntax

1) no props needed

#+BEGIN_SRC js
const PostLink = () =>
  <PostHeader>
    <PostTitle><StyledLink to={path}>{title}</StyledLink></PostTitle>
    <PostDescription>{description}</PostDescription>
  </PostHeader>
#+END_SRC

2) props without being a class

#+BEGIN_SRC js
const PostLink = props => {
  const { title, description, path } = props.postData;

  return (
    <PostHeader>
      <PostTitle><StyledLink to={path}>{title}</StyledLink></PostTitle>
      <PostDescription>{description}</PostDescription>
    </PostHeader>
  )
}
export default PostLink
#+END_SRC

3) class

#+BEGIN_SRC js
export default class PostLink extends React.Component {
  render() {
    const { title, description, path } = this.props.postData;

    return (
      <PostHeader>
        <PostTitle><StyledLink to={path}>{title}</StyledLink></PostTitle>
        <PostDescription>{description}</PostDescription>
      </PostHeader>
    );
  }
}
#+END_SRC

** Styling

*** Styled Components


**** YouTube video about styling components

#+BEGIN_SRC js
import Button from './Button';

const Home = () =>
  <div>
    <Button>btn main</Button>
    <Button primary href="https://duckduckgo.com">btn2</Button>
    <Button danger>danger</Button>
  </div>
#+END_SRC


#+BEGIN_SRC js
const Button = ({ primary, danger, className, ...props }) => {
  const Tag = props.href ? "a" : "button"

  return <Tag
    type="button"
    className={cn(
      'btn',
      primary && 'btn-primary',
      danger && 'btn-danger',
      className)}
    {...props}
  />
}

const DangerBtn = props =>
  <Button
    danger
    {...props}
  />

const PrimaryBtn = props =>
  <Button
    primary
    {...props}
  />

export default Button
#+END_SRC

* Misc

"Module request format," /a la node/: starts-with-dot is local.

** set org-babel-node command                                      :noexport:

 #+BEGIN_SRC js :cmd "org-babel-node"
let props = {
  object: {},
  string: '',
  array: []
}
console.log(props);
 #+END_SRC

 #+RESULTS:
 : { postData: { title: 'pd-title', description: 'pd-desc', path: 'pd-path' },
 :   title: 'reg-title',
 :   description: 'reg-desc',
 :   path: 'reg-path' }
 : undefined


 #+BEGIN_SRC js :cmd "org-babel-node --presets=es2015"
  const animals = ['dog', 'cat']

  animals.map((anim) => {
    console.log('anim', anim);
  })
 #+END_SRC

 #+RESULTS:
 : anim dog
 : anim cat
 : undefined
* frameworks
** Umbrella

- [[https://github.com/thi-ng/umbrella][umbrella]]
  - [[https://github.com/thi-ng/umbrella/tree/master/packages/hdom][hdom]]
- [[https://medium.com/@thi.ng/how-to-ui-in-2018-ac2ae02acdf3][How to UI in 2018]] (Medium), by Karsten Schmidt

