#+OPTIONS: toc:nil -:nil H:6 ^:nil
#+EXCLUDE_TAGS: noexport
#+STARTUP: overview
#+BEGIN_EXAMPLE
---
title: "JavaScript"
layout: notation
description:
path: "/javascript/"
---
#+END_EXAMPLE

* Books :noexport:
** Functional Programming in Javascript
Luis Atencio, Manning

[[https://manning-content.s3.amazonaws.com/download/f/3b00e17-1d45-4091-a86d-35b31222699a/Atencio_FuntionalProgrammingInJavaScript_Err13.html][errata]]

** 5 - Design Patterns Against Complexity

*** 5.2.1 - Wrapping Unsafe Values

#+BEGIN_SRC js
#+END_SRC

* Frameworks :noexport:

[[https://github.com/kriszyp/alkali][Alkali]]

https://davidwalsh.name/modernization-reactivity

* Language
** Arrays :noexport:

*** Copying

[[https://stackoverflow.com/questions/7486085/copying-array-by-value-in-javascript/23536726#23536726][Good SO answer]]

If it's an array of primitives, use ~slice()~ (or ~concat()~):

#+BEGIN_SRC js
var myArray = [3, "str", true];

var dupe = myArray.slice();
// or
var dupe2 = myArray.concat();
dupe[0] = 4;
console.log('myArray', myArray);
#+END_SRC

If it's an array of objects, this will result in a shallow copy:

#+BEGIN_SRC js
var myObjArray = [
  {
    name: 'Miles',
    instrument: 'trumpet'
  },
  {
    name: 'John',
    instrument: 'saxophone'
  }
]

var shallowDupe = myObjArray.slice();
shallowDupe[0].name = 'Clifford';

console.log('myObjArray', myObjArray); // Clifford overwrote Miles
#+END_SRC

Instead, one alternative is to stringify and parse:

#+BEGIN_SRC js
var myObjArray = [
  {
    name: 'Miles',
    instrument: 'trumpet'
  },
  {
    name: 'John',
    instrument: 'saxophone'
  }
]

var dupe = myObjArray.slice();
// dupe[0].name = 'Clifford'; // would overwrite myObjArray

var dupe2 = JSON.parse(JSON.stringify(myObjArray));
dupe2[0].name = 'Dexter'; // myObjArray and dupe2 are different
#+END_SRC

** Async

[[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/async_function][MDN]]

#+BEGIN_SRC js
async function [name]([param1[, param2[, ..., paramN]]]) {
   statements
}
#+END_SRC

Hacker Noon post [[https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9][6 Reasons Why JavaScript’s Async/Await Blows Promises Away]] from [[https://twitter.com/imGaafar][Mostafa Gaafar]]:

** Callbags

https://github.com/staltz/callbag-basics

https://www.youtube.com/watch?v=HssczgaY9BM

"What I called the 'callbag pattern.'"

"The idea is that the producer and consumer are symmetric: they have the same signature."

#+BEGIN_SRC js
function producer(type, payload) {
  if (type === 'start') {
    // on start, you know the payload is a callback
    const consumer = payload;
    let i = 0;
    let handle;

    // I can listen to the consumer with another function:
    // it's a nested callback
    consumer('start', (type, payload) => {
      if (type === 'data') i = payload;
      if (type === 'stop') clearInterval(incInt);
    });

    incInt = setInterval(() => {
      consumer('data', i);
      i++;
    }, 1000);
  }
}

function consumer(type, payload) {
  // subscribe
  if (type === 'start') {
    // you know payload is a callback
    const cb = payload;

    setTimeout(() => {
      console.log('hello')
      cb('data', 17)
    }, 1200);

    setTimeout(() => {
      // this calls the "nested callback" filtered by type === 'stop'
      // (t,p)=>{if (t==='stop') clearInterval(handle)}
      cb('stop');
    }, 3500);
  }
  if (type === 'data') {
    console.log(payload);
  }
}

producer('start', consumer);
#+END_SRC

** Currying :noexport:

Function takes two:

#+BEGIN_SRC js
const myCurryTwo = function(func) {
  return function(value) {
    func(value);
  }
}

const myCurryTwo2 = f => x => f(x)
#+END_SRC

** Destructuring :noexport:
*** Arrays

*** Objects

#+BEGIN_SRC js :cmd "org-babel-node"
  let structured = {
    title: 'structured title',
    description: 'structured desc'
  }

  const { title, description } = structured;

  console.log(title);
  console.log(description);
#+END_SRC

#+RESULTS:
: structured title
: structured desc
: undefined


#+BEGIN_SRC js :cmd "org-babel-node --presets=stage-2"
let obj1 = {
  bird: "falcon2",
  frog: "bullfrog"
}
let { bird, frog: frogName } = obj1;
console.log(bird);
console.log(frogName);

let obj2 = {
  fruit: "apple",
  veggie: "kale",
  meat: "tofuball"
}
let { fruit, ...restItem } = obj2;
console.log(fruit);
console.log(restItem);
#+END_SRC

** Events

*** keyboard

regular:

#+BEGIN_SRC js
handler = e => {
  e.preventDefault();
  if (e.key === 'd') {
    this.setState({ isDebug: !this.state.isDebug });
  }
}
componentDidMount() {
  window.addEventListener('keypress', this.handler.bind(this))
}
componentWillUnmount() {
  window.removeEventListener('keypress', this.handler)
}
#+END_SRC

setting directly on ~window.onkeyup~:

#+BEGIN_SRC js
componentDidMount() {
  const _handleKeycode = e => {
    if (e.keyCode === 68) {
      // 'd' key
      this.setState({ isDebug: !this.state.isDebug });
    } else if (e.keyCode === 75) {
      // 'k' key
      this.props.history.push('/');
      window.location.reload();
    }
  };
  window.onkeyup = _handleKeycode.bind(this);
  this.preventDefault = e => e.preventDefault();
}

componentWillUnmount() {
  window.onkeyup = null;
}
#+END_SRC

rxjs:

#+BEGIN_SRC js
constructor() {
  this.keyEvents$ = Rx.Observable.fromEvent(document, 'keydown');
}

componentDidMount() {
  this.keyPressListeners = this.keyEvents$
    .filter(
      e =>
        e.keyCode === 68 ||
        e.keyCode === 81
    )
    .debounceTime(280)
    .do(e => e.preventDefault())
    .subscribe(({ keyCode }) => {
      switch (keyCode) {
      case 68:
        // 'd' key
        this.setState({ isDebug: !this.state.isDebug });
        break;
      case 81:
        // 'q' key (for 'quit back to start screen')
        this.props.history.push('/start');
        window.location.reload();
        break;
      default:
        break;
      }
    });
}

componentWillUnmount() {
  this.keyPressListeners.unsubscribe();
}
#+END_SRC

** Indentation/formatting
** Iterators

From [[https://nostarch.com/ecmascript6][Understanding ECMASCRIPT 6]] by [[https://twitter.com/slicknet][Nicholas Zakas]]

ES5 iterator:

#+BEGIN_SRC js
const createIterator = items => {
  let i = 0;

  return {
    next: () => {
      const done = i <= items.length;
      const value = !done && items[i++];

      return {
        value: value,
        done: done,
      };
    },
  };
};
#+END_SRC

ES6 equivalent:

#+BEGIN_SRC js
const createIterator
#+END_SRC

** Promises

#+BEGIN_QUOTE
"A Promise is simply an Observable with one single emitted value." [[*post: https://gist.github.com/staltz/868e7e9bc2a7b8c1f754][Andre Staltz]]
#+END_QUOTE

*** [[https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html][Nolan Lawson's Blog Post]] :noexport:

Abbreviated:

#+BEGIN_QUOTE
Q: What is the difference between these four promises?

#+BEGIN_SRC js
doSomething().then(function () {
  return doSomethingElse();
});

doSomething().then(function () {
  doSomethingElse();
});

doSomething().then(doSomethingElse());

doSomething().then(doSomethingElse);
#+END_SRC

Mistakes outlined:

- "promisey pyramid of doom"
- ~forEach()~ instead of ~map()~
- missing ~catch()~
- using "deferred"
- side effects instead of returning
#+END_QUOTE

**** Your Three Options When Inside ~then()~

- return another promise
- return a synchronous value (or undefined)
- throw a synchronous error

#+BEGIN_QUOTE
Every promise gives you a ~then()~ method (or ~catch()~, which is just sugar for ~then(null, ...))~. Here we are inside of a ~then()~ function:

#+BEGIN_SRC js
somePromise().then(function () {
  // I'm inside a then() function!
});
#+END_SRC

There are three things:

- return another promise

#+BEGIN_SRC js
getUserByName('nolan').then(function (user) {
  return getUserAccountById(user.id);
}).then(function (userAccount) {
  // I got a user account!
});
#+END_SRC

- return a synchronous value (or undefined)

#+BEGIN_SRC js
getUserByName('nolan').then(function (user) {
  if (inMemoryCache[user.id]) {
    return inMemoryCache[user.id];    // returning a synchronous value!
  }
  return getUserAccountById(user.id); // returning a promise!
}).then(function (userAccount) {
  // I got a user account!
});
#+END_SRC

- throw a synchronous error

#+BEGIN_SRC js
getUserByName('nolan').then(function (user) {
  if (user.isLoggedOut()) {
    throw new Error('user logged out!'); // throwing a synchronous error!
  }
  if (inMemoryCache[user.id]) {
    return inMemoryCache[user.id];       // returning a synchronous value!
  }
  return getUserAccountById(user.id);    // returning a promise!
}).then(function (userAccount) {
  // I got a user account!
}).catch(function (err) {
  // Boo, I got an error!
});
#+END_SRC
#+END_QUOTE

**** Advanced Mistakes

- Not knowing about Promise.resolve()
- ~then(resolveHandler).catch(rejectHandler)~ isn't exactly the same as ~then(resolveHandler, rejectHandler)~
- Promises vs. Promise Factories
- Higher-scoped variable for combined promise results
- Promises fall through

#+BEGIN_QUOTE
- Not knowing ~Promise.resolve()~

#+BEGIN_SRC js
function somePromiseAPI() {
  return Promise.resolve().then(function () {
    doSomethingThatMayThrow();
    return 'foo';
  }).then(/* ... */);
}
#+END_SRC

Just remember: any code that might ~throw~ synchronously is a good candidate for a nearly-impossible-to-debug swallowed error somewhere down the line. But if you wrap everything in ~Promise.resolve()~, then you can always be sure to ~catch()~ it later.

- ~then(resolveHandler).catch(rejectHandler)~ isn't exactly the same as ~then(resolveHandler, rejectHandler)~

#+BEGIN_SRC js
somePromise().then(function () {
  throw new Error('oh noes');
}).catch(function (err) {
  // I caught your error! :)
});

somePromise().then(function () {
  throw new Error('oh noes');
}, function (err) {
  // I didn't catch your error! :(
});
#+END_SRC

As it turns out, when you use the ~then(resolveHandler, rejectHandler)~ format, the ~rejectHandler~ won't actually catch an error if it's thrown by the ~resolveHandler~ itself.

- Promises vs. Promise Factories

#+BEGIN_SRC js
// good, will execute sequentially as expected

function executeSequentially(promiseFactories) {
  var result = Promise.resolve();
  promiseFactories.forEach(function (promiseFactory) {
    result = result.then(promiseFactory);
  });
  return result;
}

// ...

function myPromiseFactory() {
  return somethingThatCreatesAPromise();
}
#+END_SRC

- Higher-scoped variable for combined promise results

#+BEGIN_SRC js
// no
var user;
getUserByName('nolan').then(function (result) {
  user = result;
  return getUserAccountById(user.id);
}).then(function (userAccount) {
  // okay, I have both the "user" and the "userAccount"
});

// yes
getUserByName('nolan').then(function (user) {
  return getUserAccountById(user.id).then(function (userAccount) {
    // okay, I have both the "user" and the "userAccount"
  });
});
#+END_SRC

- Promises fall through

#+BEGIN_SRC js
Promise.resolve('foo').then(null).then(function (result) {
  console.log(result);
});
#+END_SRC
#+END_QUOTE

**** [[https://gist.github.com/nolanlawson/6ce81186421d2fa109a4][Promise protips - stuff I wish I had known when I started with Promises]]

#+BEGIN_QUOTE
Promise.all is good for executing many promises at once

#+BEGIN_SRC js
Promise.all([
  promise1,
  promise2
]);
#+END_SRC

Promise.resolve is good for wrapping synchronous code

#+BEGIN_SRC js
Promise.resolve().then(function () {
  if (somethingIsNotRight()) {
    throw new Error("I will be rejected asynchronously!");
  } else {
    return "This string will be resolved asynchronously!";
  }
});
#+END_SRC

execute some promises one after the other.
this takes an array of promise factories, i.e.
an array of functions that RETURN a promise
(not an array of promises themselves; those would execute immediately)

#+BEGIN_SRC js
function sequentialize(promiseFactories) {
  var chain = Promise.resolve();
  promiseFactories.forEach(function (promiseFactory) {
    chain = chain.then(promiseFactory);
  });
  return chain;
}
#+END_SRC

Promise.race is good for setting a timeout:

#+BEGIN_SRC js
Promise.race([
  new Promise(function (resolve, reject) {
    setTimeout(reject, 10000); // timeout after 10 secs
  }),
  doSomethingThatMayTakeAwhile()
]);
#+END_SRC

Promise finally util similar to Q.finally
e.g. promise.then(...).catch().then(...).finally(...)

#+BEGIN_SRC js
function finally (promise, cb) {
  return promise.then(function (res) {
    var promise2 = cb();
    if (typeof promise2.then === 'function') {
      return promise2.then(function () {
        return res;
      });
    }
    return res;
  }, function (reason) {
    var promise2 = cb();
    if (typeof promise2.then === 'function') {
      return promise2.then(function () {
        throw reason;
      });
    }
    throw reason;
  });
};
#+END_SRC
#+END_QUOTE

*** Other References

[[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise][MDN]]

** Reduce

[[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce][MDN Array.prototype.reduce()]]

#+BEGIN_SRC js
const myArr = [1, 2, 3]
const myAdditionReducer = (acc, n) => acc + n;
myArr.reduce(myAdditionReducer); // 6
#+END_SRC

** Video

#+BEGIN_SRC js

#+END_SRC
* Libraries
** D3 :noexport:
*** force directed :noeexport:

https://beta.observablehq.com/@mbostock/d3-force-directed-graph

https://d3indepth.com/force-layout/

https://medium.com/ninjaconcept/interactive-dynamic-force-directed-graphs-with-d3-da720c6d7811

https://www.puzzlr.org/force-graphs-with-d3/

http://bl.ocks.org/eyaler/10586116

#+BEGIN_SRC js
chart = {
  const links = data.links.map(d => Object.create(d));
  const nodes = data.nodes.map(d => Object.create(d));
  const simulation = forceSimulation(nodes, links).on("tick", ticked);

  const svg = d3.select(DOM.svg(width, height))
      .attr("viewBox", [-width / 2, -height / 2, width, height]);

  const link = svg.append("g")
      .attr("stroke", "#999")
      .attr("stroke-opacity", 0.6)
    .selectAll("line")
    .data(links)
    .enter().append("line")
      .attr("stroke-width", d => Math.sqrt(d.value));

  const node = svg.append("g")
      .attr("stroke", "#fff")
      .attr("stroke-width", 1.5)
    .selectAll("circle")
    .data(nodes)
    .enter().append("circle")
      .attr("r", 5)
      .attr("fill", color)
      .call(drag(simulation));

  node.append("title")
      .text(d => d.id);

  function ticked() {
    link
        .attr("x1", d => d.source.x)
        .attr("y1", d => d.source.y)
        .attr("x2", d => d.target.x)
        .attr("y2", d => d.target.y);

    node
        .attr("cx", d => d.x)
        .attr("cy", d => d.y);
  }

  return svg.node();
}

function forceSimulation(nodes, links) {
  return d3.forceSimulation(nodes)
      .force("link", d3.forceLink(links).id(d => d.id))
      .force("charge", d3.forceManyBody())
      .force("center", d3.forceCenter());
}

data = d3.json("https://gist.githubusercontent.com/mbostock/4062045/raw/5916d145c8c048a6e3086915a6be464467391c62/miserables.json")


height = 600

color = {
  const scale = d3.scaleOrdinal(d3.schemeCategory10);
  return d => scale(d.group);
}

drag = simulation => {

  function dragstarted(d) {
    if (!d3.event.active) simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
  }

  function dragged(d) {
    d.fx = d3.event.x;
    d.fy = d3.event.y;
  }

  function dragended(d) {
    if (!d3.event.active) simulation.alphaTarget(0);
    d.fx = null;
    d.fy = null;
  }

  return d3.drag()
      .on("start", dragstarted)
      .on("drag", dragged)
      .on("end", dragended);
}

d3 = require("d3@5")
#+END_SRC

*** nvd3

[[http://nvd3-community.github.io/nvd3/examples/documentation.html][Documentation]]

create nv chart (from [[https://css-tricks.com/how-to-make-a-modern-dashboard-with-nvd3-js/][How to Make a Modern Dashboard with nvd3.js]])

#+BEGIN_SRC js
nv.addGraph(function () {
  var chart = nv.models.lineChart() // Initialise the lineChart object.
    .useInteractiveGuideline(true); // Turn on interactive guideline (tooltips)
chart.xAxis
    .axisLabel('TimeStamp (Year)'); // Set the label of the xAxis (Vertical)
chart.yAxis
    .axisLabel('Degrees (c)') // Set the label of the xAxis (Horizontal)
    .tickFormat(d3.format('.02f')); // Rounded Numbers Format.
d3.select('#averageDegreesLineChart svg') // Select the ID of the html element we defined earlier.
    .datum(temperatureIndexJSON) // Pass in the JSON
    .transition().duration(500) // Set transition speed
    .call(chart); // Call & Render the chart
  nv.utils.windowResize(chart.update); // Intitiate listener for window resize so the chart responds and changes width.
  return;
});
#+END_SRC

*** reference

https://blockbuilder.org/

[[https://medium.com/@Elijah_Meeks/interactive-applications-with-react-d3-f76f7b3ebc71][Interactive Applications with React & D3]], by Elijah Meeks

https://medium.com/technical-credit/declarative-d3-examples-in-react-6e736e526182

** Lodash :noexport:

[[https://github.com/lodash/lodash/wiki/FP-Guide][lodash wiki - FP guide]]

[[https://medium.com/making-internets/why-using-chain-is-a-mistake-9bc1f80d51ba][medium - Why Using Chain is a Mistake]]

** misc :noexport:

[[https://github.com/monet/monet.js][monet.js]]

https://github.com/funkia/hareactive

https://github.com/funkia/turbine

https://github.com/Netflix/Turbine/wiki

** Node :noexport:
*** Debugging

- [[https://nodejs.org/en/docs/inspector/][nodejs.org docs - Inspector]]
- [[https://nodejs.org/dist/latest-v8.x/docs/api/][Node.js v8.10.0 Documentation]]

*** Misc

**** nodemon

[[https://stackoverflow.com/a/31312745/1052412][SO - watching too many files]]

** Ramda :noexport:
*** Identity

#+BEGIN_SRC js
function _isPlaceholder(a) {
  return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;
}

function _identity(x) {
  return x;
}

function _curry1(fn) {
  return function f1(a) {
    if (arguments.length === 0 || _isPlaceholder(a)) {
      return f1;
    } else {
      return fn.apply(this, arguments);
    }
  };
}

var identity = _curry1(_identity);

const val = 5;
const iVal = identity(val);
console.log('iVal', iVal);
#+END_SRC

#+RESULTS:
: iVal 5
: undefined

*** hard to understand
**** setting initial redux states

#+BEGIN_SRC js
import navFooterGlobalReducer from 'reducers/navFooterGlobal';

const initialNavFooterGlobalState = {
  navFooterGlobal: [],
};

const loadReducer = R.curry((initialState, reducer, state, action) => {
  try {
    return R.invoker(2, action.type)(
      R.defaultTo(initialState, state),
      action,
      reducer
    );
  } catch (e) {
    return R.defaultTo(initialState, state);
  }
});

export default combineReducers({
  navFooterGlobal: loadReducer(
    initialNavFooterGlobalState,
    navFooterGlobalReducer
  ),
});

import reducers from './reducers';

const store = compose(
  applyMiddleware(routerMiddleware(history), thunk),
  window.__REDUX_DEVTOOLS_EXTENSION__
    ? window.__REDUX_DEVTOOLS_EXTENSION__()
    : f => f
)(createStore)(reducers);
#+END_SRC

Rather than setting initial state when combining the reducers, the redux docs show setting initial state [[https://redux.js.org/basics/reducers#handling-actions][this way]]:

#+BEGIN_SRC js
import { VisibilityFilters } from './actions'

const initialState = {
  visibilityFilter: VisibilityFilters.SHOW_ALL,
  todos: []
}

function todoApp(state = initialState, action) {
  switch (action.type) {
    case SET_VISIBILITY_FILTER:
      return Object.assign({}, state, {
        visibilityFilter: action.filter
      })
    default:
      return state
  }
}
#+END_SRC

Seems like "loadReducer" should be named "fallbackNilToInitialStateAndCatchUndefined." It's doing three things:

1 - curryingl

Secondly, I feel like "loadReducer" is misnamed. Seems like it's not "loading" a reducer, but rather applying ~R.invoker~ (in a possibly un-idiomatic way?) to use an initial state in case of null.

Re ~invoker~, it's saying "I want to call ~action.type~ with two arguments," and then immediately invoking the returned function with an arity mismatch error of 3 arguments: 1 - (R.defaultTo(initialState, state), action, reducer). First of all, it's a bit convoluted or magical here because loadReducer's try block doesn't evaluate until it's received the curried in final 2 arguments from combineReducer. This is "magical" because it currently looks like combineReducers has a set of key/value pairs where the value is a binary function... but it's not binary, because combineReudcers is passing the final two curried args in.

Re ~R.defaultTo(initialState, state)~, I'm unclear on why the ~state~ would be null. What sort of reducer would be giving a null state here?

I'm also unclear on why there's a try/catch. What type of error do we anticipate here? I would initially think "arity," but it's curried, so my gut tells me that a try/catch here might lead to more subtle bugs rather than assist in catching others..?

And why is it curried? It's only called in one very specific place in the code, to do one very specific thing (swap a null action for a fallback/default initial state), and that calls it with two arguments.

ref https://github.com/reduxjs/redux/blob/master/docs/api/combineReducers.md ...

> While combineReducers attempts to check that your reducers conform to some of these rules, you should remember them, and do your best to follow them. combineReducers will check your reducers by passing undefined to them; this is done even if you specify initial state to Redux.createStore(combineReducers(...), initialState). Therefore, you must ensure your reducers work properly when receiving undefined as state, even if you never intend for them to actually receive undefined in your own code.

... this might be the ratioanle behind the try/catch... but it seems like the rationale behind the initialStates and defatulTo as well... I suppose they're doing different things.

**** unorthodox, misnamed, convoluted, uncommented data transformation

#+BEGIN_SRC js
const idKeyAsProp = (a, b) => R.assoc(b.id, b, a);

const SavedDashboardsReducer = (state = initialState, action) => {
  switch (action.type) {
  case `${FETCH_ALL}_SUCCESS`: {
    return R.compose(
      R.assoc('data', R.__, state),
      R.reduce(idKeyAsProp, {}),
      R.pathOr([], ['payload', 'data', 'data'])
    )(action);
  }
};
#+END_SRC

This reads like a puzzle. Reducing an ~assoc~ with ~(a, b) -> (b.id, b, a)~? Difficulties:

1) ~assoc~'s signature is ~String → a → {k: v} → {k: v}~, which is surprising, particularly without extended Ramda knowledge

2) transforming an object that contains a key property into a key/value pair with said id as the key is an unorthodox data manipulation: a) why? b) doesn't this duplicate the nested 'id' property now?

3) naming error: "idKeyAsProp" should read "idPropAsKey"

#+BEGIN_SRC js
before = { id: 1, value: 'cat' }
after = { 1: { id: 1, value: 'cat' } }
#+END_SRC

The reduction is using this transformation as the iterator function to construct a new object.

#+BEGIN_SRC js
fetchResponse = [
  { id: 1, value: 'cat' },
  { id: 2, value: 'dog' }
]
reductionResult = {
  1: { id: 1, value: 'cat' },
  2: { id: 2, value: 'dog' }
}
#+END_SRC

Then ~R.assoc('data', R.__, state)~ appends the full existing ~state~ object with a key of ~'data'~:

#+BEGIN_SRC js
result = {
  1: { id: 1, value: 'cat' },
  2: { id: 2, value: 'dog' }
  'data': { <state object, whatever it might be> }
}
#+END_SRC

** React
*** emoji

[[https://medium.com/@seanmcp/%25EF%25B8%258F-how-to-use-emojis-in-react-d23bbf608bf7][How to use emojis in React]]

#+BEGIN_SRC js
<span role="img" aria-label="sheep">🐑</span>
#+END_SRC

#+BEGIN_SRC js
import React from 'react';

const Emoji = props => (
    <span
        className="emoji"
        role="img"
        aria-label={props.label ? props.label : ""}
        aria-hidden={props.label ? "false" : "true"}
    >
        {props.symbol}
    </span>

);
export default Emoji;
#+END_SRC

*** events

https://reactjs.org/docs/events.html

**** mouse

https://reactjs.org/docs/events.html#mouse-events

- onClick
- onContextMenu
- onDoubleClick
- onDrag
- onDragEnd
- onDragEnter
- onDragExit
- onDragLeave
- onDragOver
- onDragStart
- onDrop
- onMouseDown
- onMouseEnter
- onMouseLeave
- onMouseMove
- onMouseOut
- onMouseOver
- onMouseUp

*** force update

Use `this.forceUpdate()`: https://reactjs.org/docs/react-component.html#forceupdate

*** forms
**** checkboxes

Sample checkboxes:

#+BEGIN_SRC js
  constructor(props) {
    super(props);

    // start with all checkboxes checked
    this.state = {
      checkboxValues: Object.assign(
        {},
        ...this.props.filteredAccounts.map(account => ({
          [account.name]: true,
        }))
      ),
    };

    this.boundHandleInputChange = this.handleInputChange.bind(this);
  }
  handleInputChange(e, accountName) {
    console.log('e, accountName', e.target.checked, accountName);
    const checkboxUpdate = {
      [accountName]: e.target.checked,
    };
    this.setState({
      checkboxValues: merge(this.state.checkboxValues, checkboxUpdate),
    });
  }

// ...

        <tbody>
          {filteredAccounts.map(({ id, name: accountName }) => {
            const isChecked = this.state.checkboxValues[accountName];
            return (
              <Tr key={id}>
                <Td>{accountName}</Td>
                <Td>
                  <Checkbox
                    defaultChecked={isChecked}
                    value={isChecked}
                    onChange={e => this.boundHandleInputChange(e, accountName)}
                  />
                </Td>
              </Tr>
            );
          })}
        </tbody>
#+END_SRC

Note `defaultChecked`.

*** JSX
**** functional stateless component

#+BEGIN_SRC js
const Post = props => {
  const { title, description, path } = props.postData;

  return (
    <PostHeader>
      <PostTitle><StyledLink to={path}>{title}</StyledLink></PostTitle>
      <PostDescription>{description}</PostDescription>
    </PostHeader>
  )
}
#+END_SRC

props destructured:

#+BEGIN_SRC js
const Post = ({ title, description, path }) => {
  return (
    <PostHeader>
      <PostTitle><StyledLink to={path}>{title}</StyledLink></PostTitle>
      <PostDescription>{description}</PostDescription>
    </PostHeader>
  )
}
#+END_SRC

return object literal:

#+BEGIN_SRC js
const Post = ({ title, description, path }) => (
    <PostHeader>
      <PostTitle><StyledLink to={path}>{title}</StyledLink></PostTitle>
      <PostDescription>{description}</PostDescription>
    </PostHeader>
  )
#+END_SRC

return assumed (?) object literal:

#+BEGIN_SRC js
const Post = ({ title, description, path }) => <PostHeader>
      <PostTitle><StyledLink to={path}>{title}</StyledLink></PostTitle>
      <PostDescription>{description}</PostDescription>
    </PostHeader>
#+END_SRC

**** class

#+BEGIN_SRC js
class Post extends React.Component {
  constructor(props) {
    super(props);
  }
  render() {
    const { title, description, path } = this.props.postData;

    return (
        <PostHeader>
          <PostTitle><StyledLink to={path}>{title}</StyledLink></PostTitle>
          <PostDescription>{description}</PostDescription>
        </PostHeader>
    );
  }
}
#+END_SRC

**** unicode

#+BEGIN_SRC js
// no: html character entity reference
<span>{'9 &ndash; 5'}</span>

// yes: unicode
<span>{'9 \u2013 5'}</span>
#+END_SRC

*** lifecycle

https://reactjs.org/docs/react-component.html

**** componentDidUpdate(prevProps, prevState, snapshot)

https://reactjs.org/docs/react-component.html#componentdidupdate

#+BEGIN_SRC js
componentDidUpdate(prevProps, prevState, snapshot) {
  if (this.props.thing !== prevProps.thing) {
    // ...
  }
}
#+END_SRC

> ~componentDidUpdate()~ will not be invoked if ~shouldComponentUpdate()~ returns false.

**** shouldComponentUpdate

#+BEGIN_SRC js
shouldComponentUpdate(nextProps) {
  const overlayHasChanged = !isEqual(nextProps.overlay, this.props.overlay);
  // only render the first time or overlay changes
  return overlayHasChanged || this.state._hasMounted;
}
#+END_SRC

*** Redux
**** [[https://github.com/reduxjs/react-redux/blob/master/docs/api.md#connect][connect]]

#+BEGIN_SRC js
connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])

// mapStateToProps(state, [ownProps]): stateProps
// mapDispatchToProps(dispatch, [ownProps]): dispatchProps

// mergeProps(stateProps, dispatchProps, ownProps): props
//   - default is Object.assign({}, ownProps, stateProps, dispatchProps)
#+END_SRC

- ~mapStateToProps~ - subscribe to store
- ~mapDispatchToProps~ - accepts object or function, use to bind action creators
- ~mergeProps~ - select a slice of state, bind action creators to a variable

Inject todos of a specific user depending on props, and inject props.userId into the action ([[https://github.com/reduxjs/react-redux/blob/master/docs/api.md#inject-todos-of-a-specific-user-depending-on-props-and-inject-propsuserid-into-the-action][ref]]):

#+BEGIN_SRC js
import * as actionCreators from './actionCreators'

function mapStateToProps(state) {
  return { todos: state.todos }
}

function mergeProps(stateProps, dispatchProps, ownProps) {
  return Object.assign({}, ownProps, {
    todos: stateProps.todos[ownProps.userId],
    addTodo: (text) => dispatchProps.addTodo(ownProps.userId, text)
  })
}

export default connect(mapStateToProps, actionCreators, mergeProps)(TodoApp)
#+END_SRC

***** mapStateToProps

#+BEGIN_SRC js
function mapStateToProps(state) {
  return { todos: state.todos }
}

const mapStateToProps = state => {
  return { user: state.user };
};

const mapStateToProps = state => ({
  user: state.user
});

const mapStateToProps = state => ({
  user
});

// spread
const mapStateToProps = (state, ownProps) => ({
  ...state.user,
});

// destructure
const mapStateToProps = ({ user: { name, email } }) => {
  return { name, email };
};

const mapStateToProps = ({ user: { name, email } }) => ({
  name,
  email,
});
#+END_SRC

***** mapDispatchToProps

no mapping:

#+BEGIN_SRC js
// usage
this.props.dispatch(updateUser(username, email));
#+END_SRC

with mapping, as object:

#+BEGIN_SRC js
// setup
const mapDispatchToProps = {
  updateUser,
};

// connect with mdtp
export default connect(mapStateToProps, mapDispatchToProps)(Login);

// usage
updateUser(username, email);
#+END_SRC

***** mergeProps

#+BEGIN_SRC js
function mergeProps(stateProps, dispatchProps, ownProps) {
  return Object.assign({}, ownProps, {
    todos: stateProps.todos[ownProps.userId],
    addTodo: (text) => dispatchProps.addTodo(ownProps.userId, text)
  })
}
#+END_SRC

**** [[https://github.com/reduxjs/redux/blob/master/docs/api/combineReducers.md][combineReducers]]

> The ~combineReducers~ helper function turns an object whose values are different reducing functions into a single reducing function you can pass to ~createStore~.

Return ~state~ for unrecognized actions. Ensure that ~state~ is never undefined.

This will outline/highlight the top-level "slices" of the store.

#+BEGIN_SRC js
import { ui, user, widgets } from './reducers'

const rootReducer = combineReducers({
  ui,
  user,
  widgets
})

// ...

const store = createStore(
  rootReducer,
  window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()
)

ReactDOM.render(
  <Provider store={store}><App /></Provider>,
  document.getElementById('root')
)
#+END_SRC

> You may call combineReducers at any level of the reducer hierarchy. It doesn't have to happen at the top. In fact you may use it again to split the child reducers that get too complicated into independent grandchildren, and so on.

**** devtools

From the console: ~$r.store.getState()~, ~$r.store.dispatch({type:"MY_ACTION"})~

**** persist with local storage

[[https://egghead.io/lessons/javascript-redux-persisting-the-state-to-the-local-storage][egghead.io - Redux: Persisting the State to the Local Storage]], Dan Abramov

#+BEGIN_SRC js
// index.js

import reducer from './reducers';
import { loadState, saveState } from './localStorage';

const persistedState = loadState();
const store = createStore(
  reducer,
  persistedState,
  window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()
);

store.subscribe(() => {
  saveState(store.getState());
});

// localStorage.js

export const loadState = () => {
  try {
    const serializedState = localStorage.getItem('state');
    if (serializedState === null) {
      console.warn('loadState: not using local storage');
      return undefined;
    }
    return JSON.parse(serializedState);
  } catch (err) {
    console.warn('loadState error', err);
    return undefined;
  }
};

export const saveState = state => {
  try {
    const serializedState = JSON.stringify(state);
    localStorage.setItem('state', serializedState);
  } catch (err) {
    console.warn('saveState error', err);
    return undefined;
  }
};
#+END_SRC

Only include select slices:

#+BEGIN_SRC js
store.subscribe(() => {
  saveState(
    todos: store.getState().todos
  );
});
#+END_SRC

Throttle writes (~JSON.stringify(state)~ is expensive):

#+BEGIN_SRC js
import throttle from 'lodash/throttle';

store.subscribe(
  throttle(() => {
    saveState(store.getState());
  }, 1000)
);
#+END_SRC

**** thunk

https://github.com/reduxjs/redux-thunk

> A thunk is a function that wraps an expression to delay its evaluation.

#+BEGIN_SRC js
// calculation of 1 + 2 is immediate
// x === 3
let x = 1 + 2;

// calculation of 1 + 2 is delayed
// foo can be called later to perform the calculation
// foo is a thunk!
let foo = () => 1 + 2;
#+END_SRC

async dispatch:

#+BEGIN_SRC js
const INCREMENT_COUNTER = 'INCREMENT_COUNTER';

function increment() {
  return {
    type: INCREMENT_COUNTER
  };
}

function incrementAsync() {
  return dispatch => {
    setTimeout(() => {
      // Yay! Can invoke sync or async actions with `dispatch`
      dispatch(increment());
    }, 1000);
  };
}
#+END_SRC

conditional dispatch:

#+BEGIN_SRC js
const incrementIfOdd = () => (dispatch, getState) => {
    const { counter } = getState();

    if (counter % 2 === 0) {
      return;
    }

    dispatch(increment());
  };

function incrementIfOdd() {
  return (dispatch, getState) => {
    const { counter } = getState();

    if (counter % 2 === 0) {
      return;
    }

    dispatch(increment());
  };
}
#+END_SRC

*** reference

[[https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#formatting-code-automatically][CRA docs]]

*** reselect

**** withProps, setPropTypes

#+BEGIN_SRC js
export default compose(
  withProps(
    ({
      widgetData: {
        metaJson: { widgetType },
      },
    }) => ({ widgetType})
  ),
  setPropTypes({
    widgetData: PropTypes.object.isRequired,
    widgetType: PropTypes.string,
  })
)(Widget);
#+END_SRC

#+BEGIN_SRC js
export default compose(
  withProps(({ widgetData: { description, filteredWidgetData, title } }) => ({
    description,
    title,
    feedbackWidgetContents: R.compose(
      R.filter(({ feedback }) => Boolean(feedback)),
      R.map(
        R.compose(
          R.zipObj(['checkInTime', 'projectName', 'feedback']),
          RA.paths([
            ['expectedCheckinTime'],
            ['metaJson', 'projectName'],
            ['formState', 'feedback', 'message'],
          ])
        )
      )
    )(filteredWidgetData),
  })),
  setPropTypes({
    description: PropTypes.string,
    feedbackWidgetContents: PropTypes.arrayOf(
      PropTypes.shape({
        checkInTime: PropTypes.string,
        feedback: PropTypes.string,
        projectName: PropTypes.string,
      })
    ),
    title: PropTypes.string,
    widgetData: PropTypes.object.isRequired,
  })
)(FeedbackWidgetContainer);
#+END_SRC

**** withProps, withStateHandlers, setPropTypes

#+BEGIN_SRC
export default compose(
  withProps(() => {
    return {
      title: mockData.title,
      description: mockData.description,
      photoWidgetContents: mockData.filteredWidgetData,
    };
  }),
  withStateHandlers(
    ({ currentSlide = 0, isDetailView = false }, open = false) => ({
      currentSlide,
      isDetailView,
      open,
    }),
    {
      handlePreviousSlide: (
        { currentSlide },
        { photoWidgetContents }
      ) => () => ({
        currentSlide:
          currentSlide - 1 < 0
            ? photoWidgetContents.length - 1
            : currentSlide - 1,
      }),
      handleNextSlide: ({ currentSlide }, { photoWidgetContents }) => () => ({
        currentSlide:
          currentSlide + 1 > photoWidgetContents.length - 1
            ? 0
            : currentSlide + 1,
      }),
      toggleDetailView: ({ isDetailView }) => () => ({
        isDetailView: !isDetailView,
      }),
    }
  ),
  setPropTypes({
    description: PropTypes.string,
    title: PropTypes.string,
    widgetData: PropTypes.object.isRequired,
  })
)(PhotoWidgetContainer);
#+END_SRC
*** routing
**** react-router
***** analytics

[[https://bernardodiasdacruz.com/2018/04/10/integrate-google-analytics-with-react-router-v4][Integrate Google Analytics with React Router v4]], by Bernardo Dias da Cruz

***** basic setup

#+BEGIN_SRC js
// index.js
import { BrowserRouter } from 'react-router-dom';

ReactDOM.render(
    <BrowserRouter>
      <App />
    </BrowserRouter>
  document.getElementById('root')
);

// App.js
import { Link, Route, Switch } from 'react-router-dom';

<nav>
  <Link to="/">Home</Link>
  <Link to="login">Login</Link>
  <Link to="accounts">Accounts</Link>
</nav>
<Switch>
  <Route component={Home} exact path="/" />
  <Route component={Login} path="/login" />
  <Route component={Accounts} path="/accounts" />
</Switch>
#+END_SRC

***** conditional on param
#+BEGIN_SRC js
// App.js
<Route component={Task} path="/:task" />

// Task.js
componentDidMount() {
  const { match: { params: { task }}} = this.props;
  task === 'taskA' && // ...
}
#+END_SRC

***** conditional on search query

#+BEGIN_SRC js
componentDidMount() {
  const {
    location: { search },
  } = this.props;

  const showIntro = search.includes('show-intro');
  showIntro &&
    this.setState({
      ActiveSlide: ActionIntro,
    });
}
#+END_SRC
***** location

#+BEGIN_SRC js
// a basic location object
{ pathname: '/', search: '', hash: '', key: 'abc123' state: {} }
#+END_SRC

***** npm/package

~react-router~: core components

~react-router-dom~ (or ~react-router-native~): adds DOM-aware components (both include 'react-router')

[[https://github.com/ReactTraining/react-router/issues/4648][github comment]] by [[https://github.com/pshrmn][Paul Sherman]]

> Your first link is to the master branch, which at this time is v3.
>
> In v4, react-router exports the core components and functions. react-router-dom exports DOM-aware components, like <Link> (which renders an <a>) and <BrowserRouter> (which interacts with the browser's window.history ).
>
> react-router-dom re-exports all of react-router's exports, so you only need to import from react-router-dom in your project.

***** resources

- [[https://github.com/ReactTraining/react-router][github]]
- [[https://reacttraining.com/react-router/web/guides/philosophy][v4 docs (web/dom)]]

****** Paul Sherman's [[https://medium.com/@pshrmn/a-simple-react-router-v4-tutorial-7f23ff27adf][A Simple React Router v4 Tutorial]]

Use `<BrowserRouter>` as base for web, `<NativeRouter>` for RN.

#+BEGIN_SRC js
<Route path="[matched by [[https://github.com/pillarjs/path-to-regexp][path-to-regexp]]]" component|render|children />
#+END_SRC

Matching routes get `match` object:

- `url`
- `path`
- `isExact`
- `params` (route params)

`component` returns a `React.createElement` object.

`render` can receive props:

#+BEGIN_SRC js
<Route path="/match" render={props => <h1>{props.title}</h1>} />
<Route path="/next-match" render={props => (
  <PageInner {...props} data={extraProps}/>
)}/>
#+END_SRC

`children` is a pass-through, like `props.children` on a Route level. It ignores `path` attribute and always matches.

***** update when route/search changes

#+BEGIN_SRC js
  componentDidUpdate(prevProps, prevState) {
    const {
      location: { pathname: oldPath, search: oldSearch },
    } = prevProps;
    const {
      location: { pathname: newPath, search: newSearch },
    } = this.props;
    if (newPath !== oldPath) {
      console.log('route change', oldPath, newPath);
    } else if (newSearch !== oldSearch) {
      console.log('search change at same route', oldSearch, newSearch);
    }
  }
#+END_SRC

***** withRouter

https://github.com/ReactTraining/react-router/blob/master/packages/react-router/docs/api/withRouter.md

gain props: ~history~, ~location~, ~match~.

#+BEGIN_SRC
import { withRouter } from 'react-router'

// ...

export default withRouter(App);
#+END_SRC

**** reach-router

[[https://github.com/reach/router][github]]

#+BEGIN_SRC js
import { Link, Router } from '@reach/router';

<nav>
  <Link to="/">Home</Link>
  <Link to="login">Login</Link>
  <Link to="accounts">Accounts</Link>
</nav>
<Router>
  <Home path="/" />
  <Login path="/login" />
  <Accounts path="/accounts" />
</Router>
#+END_SRC

*** slots

from https://daveceddia.com/pluggable-slots-in-react-components/

#+BEGIN_SRC js
<Layout
  left={<Sidebar/>}
  top={<NavBar/>}
  center={<Content/>}
/>
#+END_SRC

#+BEGIN_SRC js
function Layout(props) {
  return (
    <div className="layout">
      <div className="top">{props.top}</div>
      <div className="left">{props.left}</div>
      <div className="center">{props.center}</div>
    </div>
  );
}
#+END_SRC

** rxjs
*** disposing/cleaning up

[[https://github.com/Reactive-Extensions/RxJS/issues/1016][github issue]]

When you unsubscribe() (aka dispose) of a subscription it will be chained back up to all of the subscriptions that it is composed of.

*** fetching

rxjs ajax method: http://reactivex.io/rxjs/class/es6/observable/dom/MiscJSDoc.js~AjaxRequestDoc.html#instance-method-createXHR

rxjs 5 ultimate example: https://chrisnoring.gitbooks.io/rxjs-5-ultimate/content/operators-and-ajax.html

from [[https://stackoverflow.com/questions/44877062/how-to-convert-a-fetch-api-response-to-rxjs-observable][SO]]: https://stackoverflow.com/questions/44877062/how-to-convert-a-fetch-api-response-to-rxjs-observable

#+BEGIN_SRC js
var result = Rx.Observable.fromPromise(fetch('http://myserver.com/'));
result.subscribe(x => console.log(x), e => console.error(e));
#+END_SRC

#+BEGIN_SRC js
const getData = (url, params) => {
    return fetch(url, params).then(r => {
        return r.ok ? r.text() : Promise.reject(`${r.statusText} ${r.status}`)
    })
}

const getDataObserver = (url, params) => Rx.Observable.fromPromise(getData())
#+END_SRC

bacon style:

#+BEGIN_SRC js
function toResultStream(request) {
  return Bacon.fromPromise($.ajax(request))
}
availabilityResponse = availabilityRequest.flatMap(toResultStream)
#+END_SRC

staltz:

#+BEGIN_SRC js
var requestStream = Rx.Observable.just('https://api.github.com/users');

var responseStream = requestStream
  .flatMap(function(requestUrl) {
    return Rx.Observable.fromPromise(jQuery.getJSON(requestUrl));
  });

responseStream.subscribe(function(response) {
  // render `response` to the DOM however you wish
});
#+END_SRC

*** interval

#+BEGIN_SRC js
this.confirmationInterval = Rx.Observable.interval(200)
  .takeUntil(() => activationHook === 'in' && !isPaused)
  .subscribe(() => {
    this.confirmationInterval.unsubscribe();
  });
#+END_SRC

*** reference

3 common errors by Chris Pawlukiewicz on medium: https://medium.com/@paynoattn/3-common-mistakes-i-see-people-use-in-rx-and-the-observable-pattern-ba55fee3d031

baconjs tutorial: https://baconjs.github.io/tutorials.html

fromEvent: http://reactivex.io/rxjs/class/es6/Observable.js~Observable.html#static-method-fromEvent

using fetch API:
https://chrisnoring.gitbooks.io/rxjs-5-ultimate/content/operators-and-ajax.html

Rxjs 5 ultimate git book: https://chrisnoring.gitbooks.io/rxjs-5-ultimate/content/

James Flight hackernoon blog post: https://hackernoon.com/using-rxjs-to-handle-http-requests-what-ive-learned-4640aaf4646c

*** split strings at ~\n~

[[https://stackoverflow.com/questions/38991362/what-is-the-reactive-way-to-read-file-line-by-line][SO ref]]

#+BEGIN_SRC js
    Rx.Observable.of('first\nstring')
      .concat(Rx.Observable.of('asdf\nzxcvzc\nsd fawef\nsdfs\n')) // parens was missing // to make sure we don't miss the last line!
      .scan(
        ({ buffer }, b) => {
          const splitted = buffer.concat(b).split('\n');
          const rest = splitted.pop();
          return { buffer: rest, items: splitted };
        },
        { buffer: '', items: [] }
      )
      // Each item here is a pair { buffer: string, items: string[] }
      // such that buffer contains the remaining input text that has no newline
      // and items contains the lines that have been produced by the last buffer
      .concatMap(({ items }) => items)
      // we flatten this into a sequence of items (strings)
      .subscribe(
        item => console.log(item),
        err => console.log(err),
        () => console.log('Done with this buffer source')
      );
#+END_SRC

**** Ben Lesh blog post

https://medium.com/@benlesh/rxjs-dont-unsubscribe-6753ed4fda87

#+BEGIN_SRC js
 updateData(data) {
  // do something framework-specific to update your component here.
 }

 onMount() {
   const data$ = this.getData();
   const cancelBtn = this.element.querySelector(‘.cancel-button’);
   const rangeSelector = this.element.querySelector(‘.rangeSelector’);
   const cancel$ = Observable.fromEvent(cancelBtn, 'click');
   const range$ = Observable.fromEvent(rangeSelector, 'change').map(e => e.target.value);

   const stop$ = Observable.merge(cancel$, range$.filter(x => x > 500))
   this.subscription = data$.takeUntil(stop$).subscribe(data => this.updateData(data));
 }

 onUnmount() {
  this.subscription.unsubscribe();
}
#+END_SRC

- compose a stream of ~stop$~ events that kill the data stream... that way, if you want to add another "stop" condition (like a timer), you can "simply merge a new observable into `stop$`"
- this "completes the observable" - there's a completion event that can be handled anytime you want to kill your observable. If you just call "unsubscribe" on `this.subscription`, you won't be notified... however `takeUntil` will notify you via the completion handler
- "There is one disadvantage here in terms of RxJS semantics, but it’s barely worth worrying about in the face of the other advantages. The semantic disadvantage is that completing an observable is a sign that the producer wants to tell the consumer it’s done, where unsubscribing is the consumer telling the producer it no longer cares about the data."

Other operators

There are many other ways to kill a stream in a more “Rx-y” way. I’d recommend checking out the following operators at the very least:

- take(n): emits N values before stopping the observable.
- takeWhile(predicate): tests the emitted values against a predicate, if it returns `false`, it will complete.
- first(): emits the first value and completes.
- first(predicate): checks each value against a predicate function, if it returns `true`, the emits that value and completes.

Summary: Use takeUntil, takeWhile, et al.

You should probably be using operators like `takeUntil` to manage your RxJS subscriptions. As a rule of thumb, if you see two or more subscriptions being managed in a single component, you should wonder if you could be composing those better.

- more composeable
- fires a completion event when you kill your stream
- generally less code
- less to manage
- fewer actual points of subscription (because fewer calls to `subscribe`)

** Umbrella :noexport:

- [[https://github.com/thi-ng/umbrella][umbrella]]
  - [[https://github.com/thi-ng/umbrella/tree/master/packages/hdom][hdom]]
- [[https://medium.com/@thi.ng/how-to-ui-in-2018-ac2ae02acdf3][How to UI in 2018]] (Medium), by Karsten Schmidt

** Prettier

[[https://prettier.io/docs/en/options.html][Prettier Options]]

With [[https://github.com/typicode/husky][husky]] and [[https://github.com/okonet/lint-staged][lint-staged]]:

#+BEGIN_SRC js
/* package.json */

// ...

"scripts": {
  "precommit": "lint-staged",

// ...

"lint-staged": {
  "src/**/*.{js,jsx,json,css,scss}": [
    "prettier --single-quote --jsx-bracket-same-line --trailing-comma es5 --write",
    "git add"
  ]
},

// ...
#+END_SRC

*** run it through files

#+BEGIN_SRC sh
prettier --single-quote --jsx-bracket-same-line --trailing-comma es5 --write "src/**/*.{js,jsx,json,css,scss}"
prettier --single-quote --jsx-bracket-same-line --trailing-comma es5 --write "**/*.js"
#+END_SRC

*** inspiration

[[https://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf][A Prettier Printer]], by Philip Wadler, published [[http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.19.635][1998]]

*** comments

#+begin_quote
Style wars are a thing of the past

Say what you like about gofmt, but it makes arguments over code style almost impossible. Just run it on save, and your code will always be consistently formatted.
#+end_quote

https://memo.barrucadu.co.uk/three-months-of-go.html

* Misc

"Module request format," /a la node/: starts-with-dot is local.

** active element

[[https://developer.mozilla.org/en-US/docs/Web/API/DocumentOrShadowRoot/activeElement][MDN]]

#+BEGIN_SRC js
myEl === document.activeElement
#+END_SRC

** set org-babel-node command                                      :noexport:

 #+BEGIN_SRC js :cmd "org-babel-node"
let props = {
  object: {},
  string: '',
  array: []
}
console.log(props);
 #+END_SRC

 #+RESULTS:
 : { postData: { title: 'pd-title', description: 'pd-desc', path: 'pd-path' },
 :   title: 'reg-title',
 :   description: 'reg-desc',
 :   path: 'reg-path' }
 : undefined


 #+BEGIN_SRC js :cmd "org-babel-node --presets=es2015"
  const animals = ['dog', 'cat']

  animals.map((anim) => {
    console.log('anim', anim);
  })
 #+END_SRC

 #+RESULTS:
 : anim dog
 : anim cat
 : undefined
* Reference

[[http://java.ociweb.com/mark/programming/JavaScript.html][Mark Volkmann's JavaScript Page]]
