#+OPTIONS: toc:nil -:nil H:6 ^:nil
#+EXCLUDE_TAGS: no_export
#+BEGIN_EXAMPLE
---
title: "JavaScript"
layout: notation
description:
path: "/javascript/"
---
#+END_EXAMPLE

* testing with code blocks

#+BEGIN_SRC js
let colors = [ "red", "purple", "green" ];
if (x) {
  console.log('cl');
}
let [ firstColor, ...remain ] = colors;
console.log(firstColor);
console.log(remain);
#+END_SRC

#+RESULTS:
: red
: [ 'purple', 'green' ]
: undefined

#+BEGIN_SRC js2
if (x) {
  console.log('zxcv');
}
let colors = [ "red", "purple", "green" ];
let [ firstColor, ...remain ] = colors;
console.log(firstColor);
console.log(remain);
#+END_SRC



* Arrays

** Copying

[[https://stackoverflow.com/questions/7486085/copying-array-by-value-in-javascript/23536726#23536726][Good SO answer]]

If it's an array of primitives, use ~slice()~ (or ~concat()~):

#+BEGIN_SRC js
var myArray = [3, "str", true];

var dupe = myArray.slice();
// or
var dupe2 = myArray.concat();
dupe[0] = 4;
console.log('myArray', myArray);
#+END_SRC

If it's an array of objects, this will result in a shallow copy:

#+BEGIN_SRC js
var myObjArray = [
  {
    name: 'Miles',
    instrument: 'trumpet'
  },
  {
    name: 'John',
    instrument: 'saxophone'
  }
]

var shallowDupe = myObjArray.slice();
shallowDupe[0].name = 'Clifford';

console.log('myObjArray', myObjArray); // Clifford overwrote Miles
#+END_SRC

Instead, one alternative is to stringify and parse:

#+BEGIN_SRC js
var myObjArray = [
  {
    name: 'Miles',
    instrument: 'trumpet'
  },
  {
    name: 'John',
    instrument: 'saxophone'
  }
]

var dupe = myObjArray.slice();
// dupe[0].name = 'Clifford'; // would overwrite myObjArray

var dupe2 = JSON.parse(JSON.stringify(myObjArray));
dupe2[0].name = 'Dexter'; // myObjArray and dupe2 are different
#+END_SRC

* Async

from [[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/async_function][MDN]]:

#+BEGIN_SRC js
async function [name]([param1[, param2[, ..., paramN]]]) {
   statements
}
#+END_SRC

Hacker Noon post from [[https://twitter.com/imGaafar][Mostafa Gaafar]]:

#+BEGIN_SRC js
const makeRequest = async () => {
  console.log(await getJSON())
  return "done"
}

makeRequest()
#+END_SRC

* Callbags

https://github.com/staltz/callbag-basics

https://www.youtube.com/watch?v=HssczgaY9BM

"What I called the 'callbag pattern.'"

"The idea is that the producer and consumer are symmetric: they have the same signature."

#+BEGIN_SRC js
function producer(type, payload) {
  if (type === 'start') {
    // on start, you know the payload is a callback
    const consumer = payload;
    let i = 0;
    let handle;

    // I can listen to the consumer with another function:
    // it's a nested callback
    consumer('start', (type, payload) => {
      if (type === 'data') i = payload;
      if (type === 'stop') clearInterval(incInt);
    });

    incInt = setInterval(() => {
      consumer('data', i);
      i++;
    }, 1000);
  }
}

function consumer(type, payload) {
  // subscribe
  if (type === 'start') {
    // you know payload is a callback
    const cb = payload;

    setTimeout(() => {
      console.log('hello')
      cb('data', 17)
    }, 1200);

    setTimeout(() => {
      // this calls the "nested callback" filtered by type === 'stop'
      // (t,p)=>{if (t==='stop') clearInterval(handle)}
      cb('stop');
    }, 3500);
  }
  if (type === 'data') {
    console.log(payload);
  }
}

producer('start', consumer);
#+END_SRC

* Currying

Function takes two:

#+BEGIN_SRC js
const everyOtherLetterTwoWords = (first, second) =>
      R.compose(
        R.tap(x => console.log('a: x', x);)
        R.concat(first, second))
#+END_SRC

* Destructuring

** Arrays

** Objects

#+BEGIN_SRC js :cmd "org-babel-node"
  let structured = {
    title: 'structured title',
    description: 'structured desc'
  }

  const { title, description } = structured;

  console.log(title);
  console.log(description);
#+END_SRC

#+RESULTS:
: structured title
: structured desc
: undefined


#+BEGIN_SRC js :cmd "org-babel-node --presets=stage-2"
let obj1 = {
  bird: "falcon2",
  frog: "bullfrog"
}
let { bird, frog: frogName } = obj1;
console.log(bird);
console.log(frogName);

let obj2 = {
  fruit: "apple",
  veggie: "kale",
  meat: "tofuball"
}
let { fruit, ...restItem } = obj2;
console.log(fruit);
console.log(restItem);
#+END_SRC

#+RESULTS:

* Iterators

From [[https://nostarch.com/ecmascript6][Understanding ECMASCRIPT 6]] by [[https://twitter.com/slicknet][Nicholas Zakas]]

ES5 iterator:

#+BEGIN_SRC js
const createIterator = items => {
  let i = 0;

  return {
    next: () => {
      const done = i <= items.length;
      const value = !done && items[i++];

      return {
        value: value,
        done: done,
      };
    },
  };
};
#+END_SRC

ES6 equivalent:

#+BEGIN_SRC js
const createIterator
#+END_SRC

* Styling

** Styled Components

*** Smashing Magazine best practices
Max Stoiber, best practices from [Smashing Magazine](https://www.smashingmagazine.com/2017/01/styled-components-enforcing-best-practices-component-based-systems/). Three main best practices:
1 - building small, focused and independent components
2 - splitting container and presentational components
    - keep data/logic ("container components that render presentational components") and presentation/styling components separate
3 - single-use CSS names

- remove the map between styles and components


*** YouTube video about styling components

#+BEGIN_SRC js
import Button from './Button';

const Home = () =>
  <div>
    <Button>btn main</Button>
    <Button primary href="https://duckduckgo.com">btn2</Button>
    <Button danger>danger</Button>
  </div>
#+END_SRC


#+BEGIN_SRC js
const Button = ({ primary, danger, className, ...props }) => {
  const Tag = props.href ? "a" : "button"

  return <Tag
    type="button"
    className={cn(
      'btn',
      primary && 'btn-primary',
      danger && 'btn-danger',
      className)}
    {...props}
  />
}

const DangerBtn = props =>
  <Button
    danger
    {...props}
  />

const PrimaryBtn = props =>
  <Button
    primary
    {...props}
  />

export default Button
#+END_SRC




* React

** Components

*** Syntax

1) no props needed

#+BEGIN_SRC js
const PostLink = () =>
  <PostHeader>
    <PostTitle><StyledLink to={path}>{title}</StyledLink></PostTitle>
    <PostDescription>{description}</PostDescription>
  </PostHeader>
#+END_SRC

2) props without being a class

#+BEGIN_SRC js
const PostLink = props => {
  const { title, description, path } = props.postData;

  return (
    <PostHeader>
      <PostTitle><StyledLink to={path}>{title}</StyledLink></PostTitle>
      <PostDescription>{description}</PostDescription>
    </PostHeader>
  )
}
export default PostLink
#+END_SRC

3) class

#+BEGIN_SRC js
export default class PostLink extends React.Component {
  render() {
    const { title, description, path } = this.props.postData;

    return (
      <PostHeader>
        <PostTitle><StyledLink to={path}>{title}</StyledLink></PostTitle>
        <PostDescription>{description}</PostDescription>
      </PostHeader>
    );
  }
}
#+END_SRC

* Ramda

** hard to understand

#+BEGIN_SRC js
const idKeyAsProp = (a, b) => R.assoc(b.id, b, a);

const SavedDashboardsReducer = (state = initialState, action) => {
  switch (action.type) {
  case `${FETCH_ALL}_SUCCESS`: {
    return R.compose(
      R.assoc('data', R.__, state),
      R.reduce(idKeyAsProp, {}),
      R.pathOr([], ['payload', 'data', 'data'])
    )(action);
  }
};
#+END_SRC

* Promises

** Nolan Lawson's Cheatsheet

[Nolan Lawson Cheatsheet gist](https://gist.github.com/nolanlawson/6ce81186421d2fa109a4):

```js
// Promise.all is good for executing many promises at once
Promise.all([
  promise1,
  promise2
]);

// Promise.resolve is good for wrapping synchronous code
Promise.resolve().then(function () {
  if (somethingIsNotRight()) {
    throw new Error("I will be rejected asynchronously!");
  } else {
    return "This string will be resolved asynchronously!";
  }
});

// execute some promises one after the other.
// this takes an array of promise factories, i.e.
// an array of functions that RETURN a promise
// (not an array of promises themselves; those would execute immediately)
function sequentialize(promiseFactories) {
  var chain = Promise.resolve();
  promiseFactories.forEach(function (promiseFactory) {
    chain = chain.then(promiseFactory);
  });
  return chain;
}

// Promise.race is good for setting a timeout:
Promise.race([
  new Promise(function (resolve, reject) {
    setTimeout(reject, 10000); // timeout after 10 secs
  }),
  doSomethingThatMayTakeAwhile()
]);

// Promise finally util similar to Q.finally
// e.g. promise.then(...).catch().then(...).finally(...)
function finally (promise, cb) {
  return promise.then(function (res) {
    var promise2 = cb();
    if (typeof promise2.then === 'function') {
      return promise2.then(function () {
        return res;
      });
    }
    return res;
  }, function (reason) {
    var promise2 = cb();
    if (typeof promise2.then === 'function') {
      return promise2.then(function () {
        throw reason;
      });
    }
    throw reason;
  });
};
```

** Nolan Lawson's Blog Post

[Nolan Lawson](https://github.com/nolanlawson)'s pouchdb [blog post](https://github.com/nolanlawson) provides a helpful overview of promise usage. Summary:

> Q: What is the difference between these four promises?
>
> ```js
> doSomething().then(function () {
>   return doSomethingElse();
> });
>
> doSomething().then(function () {
>   doSomethingElse();
> });
>
> doSomething().then(doSomethingElse());
>
> doSomething().then(doSomethingElse);
> ```

> If you know the answer, then congratulations: you're a promises ninja. You have my permission to stop reading this blog post.
>
> For the other 99.99% of you, you're in good company. Nobody who responded to my tweet could solve it, and I myself was surprised by the answer to #3. Yes, even though I wrote the quiz!

> Mistakes outlined:
>
> - "promisey pyramid of doom"
> - `forEach()` instead of `map()`
> - missing `catch()`
> - using "deferred"
> - side effects instead of returning

> ##### Your Three Options When Inside `then()`

> Seriously, this is the one weird trick that, once you understand it, will prevent all of the errors I've been talking about. You ready?
>
> Every promise gives you a then() method (or catch(), which is just sugar for then(null, ...)). Here we are inside of a then() function:
>
> ```js
> somePromise().then(function () {
>   // I'm inside a then() function!
> });
> ```

> What can we do here? There are three things:
>
> - return another promise
> - return a synchronous value (or undefined)
> - throw a synchronous error
>
> That's it. Once you understand this trick, you understand promises. So let's go through each point one at a time.

> #### 1. Return another promise
>
> ```js
> getUserByName('nolan').then(function (user) {
>   return getUserAccountById(user.id);
> }).then(function (userAccount) {
>   // I got a user account!
> });
> ```

> #### 2. Return a synchronous value (or undefined)
>
> ```js
> getUserByName('nolan').then(function (user) {
>   if (inMemoryCache[user.id]) {
>     return inMemoryCache[user.id];    // returning a synchronous value!
>   }
>   return getUserAccountById(user.id); // returning a promise!
> }).then(function (userAccount) {
>   // I got a user account!
> });
> ```

> #### 3. Throw a synchronous error
>
> ```js
> getUserByName('nolan').then(function (user) {
>   if (user.isLoggedOut()) {
>     throw new Error('user logged out!'); // throwing a synchronous error!
>   }
>   if (inMemoryCache[user.id]) {
>     return inMemoryCache[user.id];       // returning a synchronous value!
>   }
>   return getUserAccountById(user.id);    // returning a promise!
> }).then(function (userAccount) {
>   // I got a user account!
> }).catch(function (err) {
>   // Boo, I got an error!
> });
> ```

> ### Advanced Mistakes

> #### 1. Not knowing `Promise.resolve()`

> ```js
> function somePromiseAPI() {
>   return Promise.resolve().then(function () {
>     doSomethingThatMayThrow();
>     return 'foo';
>   }).then(/* ... */);
> }
> ```

> Just remember: any code that might `throw` synchronously is a good candidate for a nearly-impossible-to-debug swallowed error somewhere down the line. But if you wrap everything in `Promise.resolve()`, then you can always be sure to catch() it later.

> #### 2. `then(resolveHandler).catch(rejectHandler)` isn't exactly the same as `then(resolveHandler, rejectHandler)`

> ```js
> somePromise().then(function () {
>   throw new Error('oh noes');
> }).catch(function (err) {
>   // I caught your error! :)
> });
>
> somePromise().then(function () {
>   throw new Error('oh noes');
> }, function (err) {
>   // I didn't catch your error! :(
> });
> ```

> As it turns out, when you use the `then(resolveHandler, rejectHandler)` format, the `rejectHandler` won't actually catch an error if it's thrown by the `resolveHandler` itself.

> #### 3. Promises vs. Promise Factories

> ```js
> // good, will execute sequentially as expected
>
> function executeSequentially(promiseFactories) {
>   var result = Promise.resolve();
>   promiseFactories.forEach(function (promiseFactory) {
>     result = result.then(promiseFactory);
>   });
>   return result;
> }
>
> // ...
>
> function myPromiseFactory() {
>   return somethingThatCreatesAPromise();
> }
> ```

> #### 4. Higher-scoped varaible for combined promise results

> ```js
> // no
>
> var user;
> getUserByName('nolan').then(function (result) {
>   user = result;
>   return getUserAccountById(user.id);
> }).then(function (userAccount) {
>   // okay, I have both the "user" and the "userAccount"
> });
>
>
> // yes
>
> getUserByName('nolan').then(function (user) {
>   return getUserAccountById(user.id).then(function (userAccount) {
>     // okay, I have both the "user" and the "userAccount"
>   });
> });
> ```

> #### 5. Promises fall through

> Esoteric use case... may never come up in your code...

> ```js
> Promise.resolve('foo').then(null).then(function (result) {
>   console.log(result);
> });
> ```

** Other References

[MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)

* Misc

"Module request format," /a la node/: starts-with-dot is local.

** prettier

With <a href="https://github.com/typicode/husky" target="_blank">husky</a> and <a href="https://github.com/okonet/lint-staged" target="_blank">lint-staged</a.

#+BEGIN_SRC js
/* package.json */

// ...

"scripts": {
  "precommit": "lint-staged",

// ...

"lint-staged": {
  "src/**/*.{js,jsx,json,css,scss}": [
    "prettier --single-quote --jsx-bracket-same-line --trailing-comma es5 --write",
    "git add"
  ]
},

// ...

#+END_SRC

*** run it through files

#+BEGIN_SRC sh
prettier --single-quote --jsx-bracket-same-line --trailing-comma es5 --write "src/**/*.{js,jsx,json,css,scss}"
prettier --single-quote --jsx-bracket-same-line --trailing-comma es5 --write "**/*.js"
#+END_SRC

*** reference

<a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#formatting-code-automatically" target="_blank">CRA docs<a/>


* SCRATCH / TEST :no_export:

#+BEGIN_SRC js :cmd "org-babel-node"
let props = {
  object: {},
  string: '',
  array: []
}
console.log(props);
#+END_SRC

#+RESULTS:
: { postData: { title: 'pd-title', description: 'pd-desc', path: 'pd-path' },
:   title: 'reg-title',
:   description: 'reg-desc',
:   path: 'reg-path' }
: undefined


#+BEGIN_SRC js :cmd "org-babel-node --presets=es2015"
  const animals = ['dog', 'cat']

  animals.map((anim) => {
    console.log('anim', anim);
  })
#+END_SRC

#+RESULTS:
: anim dog
: anim cat
: undefined
