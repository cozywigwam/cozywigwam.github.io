---
layout: post
title: "React"
categories: notation
---

* react-router



** npm/package

`react-router`: core components

`react-router-dom` (or `react-router-native`): adds DOM-aware components (both include 'react-router')

[[https://github.com/ReactTraining/react-router/issues/4648][github comment]] by [[https://github.com/pshrmn][Paul Sherman]]

> Your first link is to the master branch, which at this time is v3.
>
> In v4, react-router exports the core components and functions. react-router-dom exports DOM-aware components, like <Link> (which renders an <a>) and <BrowserRouter> (which interacts with the browser's window.history ).
>
> react-router-dom re-exports all of react-router's exports, so you only need to import from react-router-dom in your project.

** resources

*** Paul Sherman's [[https://medium.com/@pshrmn/a-simple-react-router-v4-tutorial-7f23ff27adf][A Simple React Router v4 Tutorial]]

Use `<BrowserRouter>` as base for web, `<NativeRouter>` for RN.

#+BEGIN_SRC js
<Route path="[matched by [[https://github.com/pillarjs/path-to-regexp][path-to-regexp]]]" component|render|children />
#+END_SRC

Matching routes get `match` object:

- `url`
- `path`
- `isExact`
- `params` (route params)

`component` returns a `React.createElement` object.

`render` can receive props:

#+BEGIN_SRC js
<Route path="/match" render={props => <h1>{props.title}</h1>} />
<Route path="/next-match" render={props => (
  <PageInner {...props} data={extraProps}/>
)}/>
#+END_SRC

`children` is a pass-through, like `props.children` on a Route level. It ignores `path` attribute and always matches.

**** Location Object

#+BEGIN_SRC js
// a basic location object
{ pathname: '/', search: '', hash: '', key: 'abc123' state: {} }
#+END_SRC


* JSX
** Conditionals
*** simple if
#+BEGIN_SRC js :cmd "org-babel-node"
{
  props.link.isAvailable &&
  <Link to={ head.link.url }>{ props.link.name </Link>
}
#+END_SRC

*** simple if, larger
#+BEGIN_SRC
{ this.state.isOverlayOpen &&
  <Overlay>
    <h1>Site Name</h1>
    <Nav/>
  </Overlay>
}
#+END_SRC

*** child calls parent function

#+BEGIN_SRC js
const Child = props => (
  <div>
    <button onClick={props.onClickToggle}
  </div>
)
class Parent extends component {
  constructor(props) {
    super(props);
  }
  onToggle() {
    console.log('onToggle()');
  }
  render() {
    return (
        <div>
        <Child onClickToggle={() => onToggle().bind(this)}/>
        </div>
    )
  }
}


#+END_SRC

* 3rd-party
** Phenomic
*** Custom Layout

[[https://phenomic.io/docs/getting-started/#the-body][docs]]

- register layout in `src/routes.js`, add file to `/src/layouts/`
- head values map to `props.head`

*** Scaffolds
**** Base styled component

#+BEGIN_SRC js
import React from "react"
import PropTypes from 'prop-types'

import styles from "./index.css"

const ExampleComponent = (props) => (
  <div className={ styles.layout }>
    { props.children }
  </div>
)

ExampleComponent.propTypes = {
  children: PropTypes.node,
}

export default ExampleComponent
#+END_SRC

#+BEGIN_SRC css
.layout {
  margin: var(--base-margin);
}
#+END_SRC

**** Styled component with prop options

#+BEGIN_SRC js
import React, { PropTypes } from "react"
import cx from "classnames"

import styles from "./index.css"

const Button = ({ className, secondary, big, ...otherProps }) => (
  <span
    role="button"
    { ...otherProps }
    className={ cx({
      [className]: className,
      [styles.button]: true,
      [styles.secondary]: secondary,
      [styles.big]: big,
    }) }
  />
)

Button.propTypes = {
  children: PropTypes.node,
  className: PropTypes.string,
  secondary: PropTypes.bool,
  big: PropTypes.bool,
}

Button.displayName = "Button"

export default Button
#+END_SRC

#+BEGIN_SRC css
.button {
  display: inline-flex;
  padding: 0 1rem;
  color: var(--colorPrimary);
}
.secondary {
  color: var(--colorSecondary);
}
.big {
  font-size: 1.5rem;
}
#+END_SRC

Usage:

#+BEGIN_SRC js
import Button from "../../components/Button"

// ...

<Button secondary>{ "Read More â†’" }</Button>
#+END_SRC

** Gatsby
*** Add Collection Type

#+BEGIN_SRC js :cmd "org-babel-node"
// /pages/index.jsx

  renderNotationHeadingGroups(route) {
    const posts = [];
    route.pages.map(page => {
      if (page.data.layout === 'notation') {
        posts.push(page);
      }
    });

    return posts.map(post => {
      return <HeadingGroup key={uuid()} title={ post.data.title } description={ post.data.description } path={ post.data.path } />
    });
  }
#+END_SRC

#+BEGIN_SRC js :cmd "org-babel-node"
// /wrappers/md.jsx

    if (layout === 'notation' || layout === 'page') {
      template = <Post {...this.props} />;
    } else if (layout === 'error') {
      template = <Error {...this.props} />;
    }
#+END_SRC

* Misc
** Skeleton component

Old-school:

#+BEGIN_SRC js

import React from 'react'

export default class Component extends React.Component {
}

#+END_SRC

Newer-school:

#+BEGIN_SRC js
// component/index.js

import React, { Component } from 'react'

import cx from 'classnames'

import styles from './index.css'

class Component extends Main {
    constructor(props, { metadata }) {
      super(...arguments)

      this.state = {
        metadata: metadata,
        data: [],
        string: '',
        isToggle: false,
        isStoreToggle: MyStore.isStoreToggle(),
      }
    }

    // lifecycle
    render() {
      const content = (
        <div className={ styles.wrapper }>
          <div className={ cx({
              [styles.isToggle]: this.state.isToggle,
            })
          }>

          <BodyContainer>
            { this.props.body }
            { this.renderCollectionNav() }
          </BodyContainer>
        </div>
      return (
        <div>
          { this.state.isStoreToggle ? content : '' }
        </div>
      )
    }
  }
}

#+END_SRC

#+BEGIN_SRC css
/* component/index.css */
@import '../../styles/media-queries.css';

.wrapper {
  position: relative;
  z-index: 1;
}
.wrapper.isToggle {
  background: green;
}
#+END_SRC
