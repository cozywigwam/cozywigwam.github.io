#+OPTIONS: toc:nil -:nil H:6 ^:nil
#+EXCLUDE_TAGS: noexport
#+STARTUP: overview
* Data Structures

| Maps    | ~{:id 1 :name "test"}~      |
| Vectors | ~[1 2 3]~                   |
| Lists   | ~'(1 2 3)~                  |
| Sets    | ~#{:a "apple" :b "banana"}~ |

** maps

#+BEGIN_SRC clojure
(def a {:x 1 :y 2})
(:x a)
#+END_SRC

** Vectors

[[https://hypirion.com/musings/understanding-persistent-vector-pt-1][Understanding Clojure's Persistent Vectors, pt. 1]], by [[https://github.com/hyPiRion][Jean Niklas L’orange]]

* Datomic & DataScript :noexport:

- [[http://tonsky.me/blog/datascript-internals/][A shallow dive into DataScript internals]]
- [[https://github.com/tonsky/datascript][DataScript github]]
- [[https://docs.datomic.com/on-prem/index.html][Datomic docs]]

* Extensible Data Notation (EDN)

https://github.com/edn-format/edn

* io

List ~*.md~ filenames in ~resources/public/markdown~ dir:

#+begin_src clojure
(for [^File file (seq (.listFiles (io/file (io/resource "public/markdown"))))
      :when (re-find #"md$" (.getName file))]
  (.getName file))
#+end_src

** reference

http://clojure-doc.org/articles/cookbooks/files_and_directories.html

* machine learning :noexport:

- [[http://nils-blum-oeste.net/image-analysis-with-clojure-up-and-running-with-opencv/][Image analysis with Clojure and OpenCV: A face detection example]]
- https://gist.github.com/nblumoe/5468625

* language
** for                                                            :noexport:

#+BEGIN_SRC clojure
(def as [a a])
(for [{n :x} as] n)
(for [{n :x} as :let [x (:x n) y (:y n)]] n)
(for [{n :x} as :let [{x :x} n) {y :y} n]] n)

(for [word ["blah" "other"]] (format "%s" word)

(for [x (:edges @app-state)] (:name (:a-component x)))

(for [{x :a-component} (:edges @app-state)] x)
#+END_SRC

[[http://clojure-doc.org/articles/cookbooks/files_and_directories.html][Recipes]]

** functions

(Illustration only) function as lambda binding:

#+BEGIN_SRC clojure
(def factorial
  (fn [n]
    (loop [count n acc 1]
      (if (zero? count)
        acc
        (recur (dec count) (* acc count))))))
#+END_SRC

...as opposed to ("regular"):

#+BEGIN_SRC clojure
(defn fact-defn [n]
  (loop [x n, k 1]
    (if (zero? x)
      k
      (recur (dec x) (* k x)))))
#+END_SRC

** let

#+BEGIN_SRC clojure
(defn xab [x]
  (let [a x b x]
    {:a a :b b}))
#+END_SRC

** namespaces

ref. https://clojure.org/reference/namespaces

- Creating and switching to a namespace: in-ns ns create-ns
- Adding to a namespace: alias def import intern refer
- Finding what namespaces exist: all-ns find-ns
- Examining a namespace: ns-name ns-aliases ns-imports ns-interns ns-map ns-publics ns-refers
- Getting a namespace from a symbol: resolve ns-resolve namespace
- Removing things: ns-unalias ns-unmap remove-ns

#+begin_src clojure
(ns-publics 'myns.core)
(ns-aliases 'myns.core)
(clojure.repl/dir myns.core)
#+end_src

** threading

Equivalent thread and compose

#+begin_src clojure
(defn get-name [f] (.getName f))
(defn md? [f] (re-find #"md$" f))

(def files (filter #(md? (.getNme %)) (seq (.listFiles (io/file (io/resource "public/markdown"))))))
(defn remove-extension [s] (clojure.string/replace s #"\.md$" ""))

(map (comp remove-extension get-name) files)
(map #(-> % get-name remove-extension) files)
#+end_src

** next

next vs. rest?

> Use `next' when you are definitely about to force it with `seq', `empty?', or something anyway, `rest' otherwise. `reduce' qualifies for the former.

[[https://twitter.com/S11001001][Stephen Campbell]], at https://grokbase.com/t/gg/clojure/122s341d7e/next-vs-rest-and-reduce

#+BEGIN_SRC clojure
(def very-lazy (-> (iterate #(do (print \.) (inc %)) 1) rest rest rest))
(def less-lazy (-> (iterate #(do (print \.) (inc %)) 1) next next next))

(println (first very-lazy))
(println (first less-lazy))
#+END_SRC

** sequences

- [[http://timothypratley.blogspot.com/2017/01/reagent-deep-dive-part-3-sequences.html][Reagent deep dive part 3: Sequences]], by [[https://timothypratley.blogspot.com/p/httpswww.html][Timothy Pratley]]

** symbols

Cannot start with a number. Otherwise alphanumeric union ~+~, ~-~, ~*~, ~/~, ~!~, ~?~, ~.~, ~_~, ~<~, ~>~, ~=~, and ~'~. ~/~, ~.~, and ~:~ have restrictions.

https://clojure.org/reference/reader

* libraries
** figwheel-main

https://figwheel.org/

project.clj

#+begin_src clojure
:dependencies [[com.bhauman/figwheel-main "x.x.x"]
               [com.bhauman/rebel-readline-cljs "x.x.x"]]
 ;; setup target as a resource path
:resource-paths ["target" "resources"]
;; set up an alias to invoke your figwheel build
:aliases {"fig" ["trampoline" "run" "-m" "figwheel.main"]
          "build-dev" ["trampoline" "run" "-m" "figwheel.main" "-b" "dev" "-r"]
          "fig:min"   ["run" "-m" "figwheel.main" "-O" "advanced" "-bo" "dev"]
          "fig:test"  ["run" "-m" "figwheel.main" "-co" "test.cljs.edn" "-m" myns.test-runner]}}
#+end_src

dev.cljs.edn

#+begin_src clojure
{:main example.core}
#+end_src

or

#+begin_src clojure
^{:watch-dirs ["src"]
  :css-dirs ["resources/public/css"]
  :auto-testing false}
{:main sunflowerseastar.core}
#+end_src

~src/example/core.cljs~

#+begin_src clojure
(ns example.core)

(enable-console-print!)

(prn "hello world!")
#+end_src

#+begin_src sh
lein trampoline run -m figwheel.main -- -b dev -r
#+end_src

| ~-b dev~, ~--build dev~ | read ~dev.cljs.edn~ |
| ~-r~, ~--repl~          | launch REPL         |

using aliases

#+begin_src sh
lein fig -- -b dev -r
lein build-dev
lein fig:min
#+end_src

** hiccup

style, class:

 #+begin_src clojure
(defn wrapper-component [inner]
  [:div {:class "test-class" :style {:border "3px solid red"}} inner])
 #+end_src

** incanter

- https://github.com/incanter/incanter/wiki
- https://github.com/incanter/incanter/wiki/datasets
- http://incanter.org/docs/data-sorcery-light-new.pdf
- https://github.com/incanter/incanter/wiki/matrices
- https://github.com/incanter/incanter/wiki/sample-plots-in-incanter
- https://data-sorcery.org/2010/04/14/latex/

** Leiningen

[[https://github.com/technomancy/leiningen/blob/master/sample.project.clj][options]]

To go to existing namespace:

#+BEGIN_SRC clojure
(load "my_project/core")

;; then

(in-ns 'my-project.core)
#+END_SRC

Or in ~project.clj~:

#+BEGIN_SRC clojure
:repl-options {:init-ns my-project.core}
#+END_SRC

User profile location: =~/.lein/profiles.clj=:

#+begin_src clojure
{:user {:plugins [[cider/cider-nrepl "0.20.0-SNAPSHOT"]]
        :dependencies [[org.clojure/test.check "0.9.0"]]}}
#+end_src

**** misc

#+begin_src sh
lein deps :tree
#+end_src

** nREPL/cider

[[https://juxt.pro/blog/posts/nrepl.html][Overview of the nREPL – {:op "describe"}]], by Dominic Monroe

https://nrepl.readthedocs.io/en/latest/design/

> nREPL largely consists of three abstractions: handlers, middleware, and transports. These are roughly analogous to the handlers, middleware, and adapters of Ring, though there are some important semantic differences. Finally, nREPL is fundamentally message-oriented and asynchronous (in contrast to most REPLs that build on top of streams provided by e.g. terminals).

> ~id~ is for tracking a single message, and ~sessions~ are for tracking remote state

~*nrepl-messages*~ nREPL requests & responses

| ~C-c M-d~   | ~cider-describe-connection~ |
| ~SPC m s c~ | ~cider-repl-clear-buffer~   |

** Om

- https://circleci.com/blog/why-we-use-om-and-why-were-excited-for-om-next/
- https://plumatic.github.io//om-sweet-om-high-functional-frontend-engineering-with-clojurescript-and-react

** Quil

[[https://github.com/quil/quil][- github]]
[[http://www.tylerlhobbs.com/writings/using-quil-for-artwork][- Using Quil for Artwork]], by Tyler Hobbs
- [[http://nbeloglazov.com/2014/05/29/quil-intro.html][Quil Intro]], by [[https://github.com/nbeloglazov][Nikita Beloglazov]]
- [[http://quil.info/api][API]]
- [[http://quil.info/sketches/create][Create]]
- [[https://github.com/quil/quil/wiki][Wiki]]
- [[https://github.com/yogthos/quil-reagent-demo][quil-reagent-demo]]

** secretary

https://github.com/clj-commons/secretary

**** reference

https://yogthos.net/posts/2014-08-14-Routing-With-Secretary.html

** stylefy

#+begin_src clojure
(def button-style {:padding "1em"
                   :border "3px solid magenta"})

(defn- button [text]
  [:div (use-style button-style) text])
#+end_src

* misc
** constants

Use ~:const~ metadata tag ([[https://clojurefun.wordpress.com/2012/08/14/performance-tip-defining-constants/][ref]]):

#+BEGIN_SRC clojure
(def ^:const avoid-reflection 10)
#+END_SRC

> As is commonly the case, the biggest performance win in Clojure comes from avoiding reflection.

** decimal to hexadecimal

#+BEGIN_SRC clojure
(require '[clojure.string :as str])

(defn b10->b16 [n]
  ((into (vec (range 0 10)) [\a \b \c \d \e \f]) n))

(defn str-rems [n]
  (if (zero? n)
    0
    (str (b10->b16 (rem n 16)) (str-rems (quot n 16)))))

(defn dec->hex [n]
  (-> n
      str-rems
      str/reverse
      (str/replace #"^0+" "")))
#+END_SRC

** hashes with spec/gen                                           :noexport:

from https://news.ycombinator.com/item?id=18776697, found via https://twitter.com/jlongster/status/1078666653662150657

> Yes, I could show you a simple example:
>
> Let's create our own 78 digits long string type:

#+BEGIN_SRC clojure
(require '[clojure.spec.alpha :as s])

(def hex-digit (set "0123456789"))

(defn hex-digit? [x]
  (contains? hex-digit x))

(defn hex-str? [s]
  (every? hex-digit? (seq s)))

(s/def ::hash
  (s/and hex-str? #(= (count %) 78)))
#+END_SRC

> ::hash is now registered, now we go to the REPL:

#+BEGIN_SRC clojure
(s/valid? ::hash "23179372")

;;=> false

(s/valid? ::hash "nope93721907914920047210715459933122004671648400678953445710500236944435987060")

;;=> false

(s/valid? ::hash "231793721907914920047210715459933122004671648400678953445710500236944435987060")

;;=> true
#+END_SRC

> That's cool, but we want to generate too:

#+BEGIN_SRC clojure
(require '[clojure.spec.gen.alpha :as g])

(defn hex-str-gen [n]
  (let [digit (g/elements hex-digit)]
    (g/fmap clojure.string/join (g/vector digit n))))

(s/def ::hash
  (s/with-gen
    (s/and
     hex-str?
     #(= (count %) 78))
    #(hex-str-gen 78)))
#+END_SRC

> We extended our ::hash spec with a generator function, so we can do this now:

#+BEGIN_SRC clojure
(g/generate (s/gen ::hash))

;;=> "310584715385467847758653938894742415543975445356609397864862925839413265904779"
#+END_SRC

> (+ Pro tip: you could spec functions too)
>
> Learn more about spec here: https://clojure.org/guides/spec

** hexadecimal to decimal

#+BEGIN_SRC clojure
(defn b16->b10 [n]
  ((zipmap
    (into
     (vec (flatten (map (comp sequence str) (range 0 10))))
     (seq "abcdef"))
    (range))
   n))

(defn pow [x n] (reduce * (repeat n x)))

(defn hex->dec [n]
  (->> n
      str
      seq
      (map b16->b10)
      reverse
      (map-indexed #(* (pow 16 %1) %2))
      (reduce +)))
#+END_SRC

** least-valued elements of unsorted list

Idea from http://book.realworldhaskell.org/read/why-functional-programming-why-haskell.html

#+BEGIN_SRC clojure
;; find the k least-valued elements of an unsorted list

(def unsorted-list2 (map (fn [_] (rand-int 20)) (repeat 20 0)))

;; put first n numbers into sorted array
;; if curr < last, pop last and (sort (conj coll curr))

(defn find-least-valued-elements
  ([coll k] (find-least-valued-elements
             (drop k coll)
             (max k (count coll))
             (vec (sort (take k coll)))))
  ([coll k least-coll]
   (cond (empty? coll) least-coll
         (< (first coll) (last least-coll))
         (find-least-valued-elements (rest coll) k
                                     (vec (sort (conj (pop least-coll) (first coll)))))
         :else (find-least-valued-elements (rest coll) k least-coll))))

(find-least-valued-elements unsorted-list2 11)
#+END_SRC

** slowdowns in emacs :noexport:

cider-font-lock-reader-conditionals

set cider-font-lock-dynamically to nil

https://github.com/clojure-emacs/cider/issues/2281

(setq cider-mode-line " cider")

** style guides

- [[https://dev.clojure.org/display/community/Library+Coding+Standards][Clojure Community - Library Coding Standards]]
- [[https://github.com/bbatsov/clojure-style-guide][The Clojure Style Guide]], by [[https://twitter.com/bbatsov][Bozhidar Batsov]]

#+BEGIN_QUOTE
Use seq as a terminating condition to test whether a sequence is empty (this technique is sometimes called nil punning). [link]
#+END_QUOTE

#+BEGIN_SRC clojure
;; good
(defn print-seq [s]
  (when (seq s)
    (prn (first s))
    (recur (rest s))))

;; bad
(defn print-seq [s]
  (when-not (empty? s)
    (prn (first s))
    (recur (rest s))))
#+END_SRC

Other misc:

#+BEGIN_SRC clojure
;; good
(if-let [result (foo x)]
  (something-with result)
  (something-else))

;; good
(when-let [result (foo x)]
  (do-something-with result)
  (do-something-more-with result))

;; good
(if-not pred
  (foo))

;; good
(not= foo bar)

;; bad
(not (= foo bar))

;; good
(< 5 x 10)

;; bad
(and (> x 5) (< x 10))

;; good
(filter even? (range 1 10))

;; bad
(filter #(even? %) (range 1 10))

;; good
(filter (complement some-pred?) coll)

;; bad
(filter #(not (some-pred? %)) coll)

;; Assuming `(:require [clojure.string :as str])`...

;; good
(map #(str/capitalize (str/trim %)) ["top " " test "])

;; better
(map (comp str/capitalize str/trim) ["top " " test "])

;; good
(map #(+ 5 %) (range 1 10))

;; (arguably) better
(map (partial + 5) (range 1 10))

;; good
(-> [1 2 3]
    reverse
    (conj 4)
    prn)

;; not as good
(prn (conj (reverse [1 2 3])
           4))

;; good
(->> (range 1 10)
     (filter even?)
     (map (partial * 2)))

;; not as good
(map (partial * 2)
     (filter even? (range 1 10)))

;; good
(cond
  (= x 10) :ten
  (= x 20) :twenty
  (= x 30) :thirty
  :else :dunno)

;; much better
(condp = x
  10 :ten
  20 :twenty
  30 :thirty
  :dunno)

;; best
(case x
  10 :ten
  20 :twenty
  30 :forty
  :dunno)

;; good
(def ^:private a 5)

;; bad
(def ^{:private true} a 5)

;; good
(defn- private-fun [] ...)

(def ^:private private-var ...)

;; bad
(defn private-fun [] ...) ; not private at all

(defn ^:private private-fun [] ...) ; overly verbose

(def private-var ...) ; not private at all

;; good
(defn f->c ...)

;; not so good
(defn f-to-c ...)

;; good
(let [[a b _ c] [1 2 3 4]]
  (println a b c))

(dotimes [_ 3]
  (println "Hello!"))

;; bad
(let [[a b c d] [1 2 3 4]]
  (println a b d))

(dotimes [i 3]
  (println "Hello!"))

;; good
(defn frobnitz
  "This function does a frobnitz.
  It will do gnorwatz to achieve this, but only under certain
  circumstances."
  []
  ...)

;; bad
(defn frobnitz
  "This function does a frobnitz. It will do gnorwatz to
  achieve this, but only under certain circumstances."
  []
  ...)

;; good
(defn foo
  "docstring"
  [x]
  (bar x))

;; bad
(defn foo [x]
  "docstring"
  (bar x))
#+END_SRC

- Use ~lisp-case~ for function and variable names.
- Use ~CamelCase~ for protocols, records, structs, and types. (Keep acronyms like HTTP, RFC, XML uppercase.)

Follow clojure.core's example for idiomatic names like pred and coll.

functions:

| ~f~, ~g~, ~h~ | function input               |
| ~n~           | integer input usually a size |
| ~index~, ~i~  | integer index                |
| ~x~, ~y~      | numbers                      |
| ~xs~          | sequence                     |
| ~m~           | map                          |
| ~s~           | string input                 |
| ~re~          | regular expression           |
| ~coll~        | a collection                 |
| ~pred~        | a predicate closure          |
| ~& more~      | variadic input               |
| ~xf~          | xform, a transducer          |

macros:

| ~expr~    | an expression          |
| ~body~    | a macro body           |
| ~binding~ | a macro binding vector |

> Avoid writing comments to explain bad code. Refactor the code to make it self-explanatory.

| ~TODO~     |
| ~FIXME~    |
| ~OPTIMIZE~ |
| ~HACK~     |
| ~REVIEW~   |

** transducers

[[http://clj-me.cgrand.net/2014/10/08/these-arent-the-reducing-functions-you-are-looking-for/][These aren’t the reducing functions you are looking for]], by [[https://github.com/cgrand][Christophe Grand]]

* recursion

Without tail call optimization (since it is not implicit):

#+BEGIN_SRC clojure
(defn no-tc-count [n]
  (if (zero? n)
    0
    (inc (no-tc-count (- n 1)))))
#+END_SRC

With tail call optimization using ~loop~ & ~recur~:

#+BEGIN_SRC clojure
(defn tc-count [n]
  (loop [x n, k 0]
    (if (zero? x)
      k
      (recur (dec x) (inc k)))))
#+END_SRC

* reference

- [[http://www.4clojure.com/][4Clojure]]
- [[https://clojure.org/api/cheatsheet][API Cheatsheet]]
- [[https://en.wikibooks.org/wiki/Learning_Clojure/Data_Structures][WikiBooks Learning Clojure Data Structure]]
- [[https://github.com/clojure-cookbook/clojure-cookbook][Clojure Cookbook github]]
- [[https://purelyfunctional.tv/guide/reagent/][Guide to Reagent]], by [[https://lispcast.com/about/][Eric Normand]]
- [[http://tonsky.me/blog/the-web-after-tomorrow/][The Web After Tomorrow]], by Nikita Prokopov/Tonsky
- [[https://data-sorcery.org/book-recommendations/][Incanter Book Recommendations]]
- https://clojurelibs.top/top

* repl :noexport:

#+begin_src clojure
(ns-publics 'myns.core)
(ns-aliases 'myns.core)
(clojure.repl/dir myns.core)
#+end_src

* test.check (spec/gen) :noexport:

- https://github.com/clojure/test.check/blob/master/doc/cheatsheet.md
- https://github.com/clojure/test.check/blob/master/doc/intro.md

